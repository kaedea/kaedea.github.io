<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MOE STUDIO</title>
  <subtitle>萌の軌跡・願いの叶う場所</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kaedea.com/"/>
  <updated>2016-06-30T12:02:41.000Z</updated>
  <id>http://kaedea.com/</id>
  
  <author>
    <name>Kaede Akatsuki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>魔都漫展 COMICCUP18 写真</title>
    <link href="http://kaedea.com/2016/07/01/living-cp18-pictures/"/>
    <id>http://kaedea.com/2016/07/01/living-cp18-pictures/</id>
    <published>2016-06-30T16:00:00.000Z</published>
    <updated>2016-06-30T12:02:41.000Z</updated>
    
    <content type="html">&lt;div class=&quot;figure right fig-50&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/57295717.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/57295717.jpg?imageView2/2/w/650/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/2409459.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/2409459.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/MG_0041.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/MG_0041.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/72384345.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/72384345.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/92361087.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/92361087.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
</content>
    
    <summary type="html">
    
      &lt;div class=&quot;figure right fig-50&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/57295717.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/57295717.jpg?imageView2/2/w/650/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/2409459.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/2409459.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/MG_0041.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/MG_0041.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/72384345.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/72384345.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;figure right fig-25&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/92361087.jpg&quot; title=&quot;&quot; data-fancybox-group=&quot;&quot;&gt;&lt;img class=&quot;fig-img&quot; src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-30/92361087.jpg?imageView2/2/w/350/interlace/1&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Living" scheme="http://kaedea.com/categories/Living/"/>
    
    
      <category term="CP18" scheme="http://kaedea.com/tags/CP18/"/>
    
      <category term="写真" scheme="http://kaedea.com/tags/%E5%86%99%E7%9C%9F/"/>
    
      <category term="漫展" scheme="http://kaedea.com/tags/%E6%BC%AB%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>自动给你的博客的中英文间加上空格</title>
    <link href="http://kaedea.com/2016/06/26/front-auto-space/"/>
    <id>http://kaedea.com/2016/06/26/front-auto-space/</id>
    <published>2016-06-25T16:00:00.000Z</published>
    <updated>2016-06-26T10:47:10.000Z</updated>
    
    <content type="html">&lt;p&gt;关于“是否应该在中文和英文之间加上空格”的争论在 &lt;code&gt;知乎&lt;/code&gt; 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;吓得我赶紧加上空格了。 (〃ﾉωﾉ)&lt;/p&gt;
&lt;h2 id=&quot;自动加空格的工具-pangu-js&quot;&gt;&lt;a href=&quot;#自动加空格的工具-pangu-js&quot; class=&quot;headerlink&quot; title=&quot;自动加空格的工具 pangu.js&quot;&gt;&lt;/a&gt;自动加空格的工具 &lt;a href=&quot;https://github.com/vinta/pangu.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pangu.js&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/vinta/pangu.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pangu.js&lt;/a&gt; 是一个综合的开源项目，包括了各种平台的“自动加空格”的工具（库），比如浏览器插件、Java、Object-C、Ruby等。比如我自己，需要用在自己的博客上，所以选择了JavaScript。&lt;/p&gt;
&lt;h2 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h2&gt;&lt;p&gt;1、先在你的网页里引入以下JS文件&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;https://cdnjs.cloudflare.com/ajax/libs/pangu/3.2.1/pangu.min.js&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、然后在适当的时刻（比如加载完网页的时候）调用以下语句即可&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script pangu.spacingPage();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然 &lt;a href=&quot;https://github.com/vinta/pangu.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pangu.js&lt;/a&gt; 还有其他多种用法，具体使用方式请自行参考GitHub项目里的使用教程。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关于“是否应该在中文和英文之间加上空格”的争论在 &lt;code&gt;知乎&lt;/code&gt; 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。&lt;br&gt;
    
    </summary>
    
      <category term="FrontEnd" scheme="http://kaedea.com/categories/FrontEnd/"/>
    
    
      <category term="JavaScript" scheme="http://kaedea.com/tags/JavaScript/"/>
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
      <category term="自动加空格" scheme="http://kaedea.com/tags/%E8%87%AA%E5%8A%A8%E5%8A%A0%E7%A9%BA%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>HEXO THEME THEMIA 1.7</title>
    <link href="http://kaedea.com/2016/06/24/hexo-theme-themia-1.7/"/>
    <id>http://kaedea.com/2016/06/24/hexo-theme-themia-1.7/</id>
    <published>2016-06-23T16:00:00.000Z</published>
    <updated>2016-06-26T08:25:45.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-24/23334229.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Themia&lt;/strong&gt; 是一个华丽的Hexo响应式主题，由 &lt;strong&gt;LouisBarranqueiro&lt;/strong&gt; 开发的主题&lt;a href=&quot;https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TranquiPeak&lt;/a&gt;的基础上改造而来，&lt;strong&gt;大部分功能都是原有主题的&lt;/strong&gt;，只是为了我自己的需求做了小部分的修改，主要是针对中文适配做的修改。&lt;/p&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加1080P等大屏显示器下的SideBar样式；&lt;/li&gt;
&lt;li&gt;调整文章的样式，比如字体、字体大小、对齐等；&lt;/li&gt;
&lt;li&gt;中英混排自动加入空格（参考 &lt;a href=&quot;https://github.com/vinta/pangu.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pangu.js&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;同步更新至 TranquiPeak 1.7.1；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将项目根目录的所有文件复制进一个文件夹，并把该文件夹复制进Hexo项目的themes目录下，再把Hexo的配置文件_config.yml中的theme标签的指改为该文件夹的名称即可。&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-24/23334229.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Themia&lt;/strong&gt; 是一个华丽的Hexo响应式主题，由 &lt;strong&gt;LouisBarranqueiro&lt;/strong&gt; 开发的主题&lt;a href=&quot;https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme&quot;&gt;TranquiPeak&lt;/a&gt;的基础上改造而来，&lt;strong&gt;大部分功能都是原有主题的&lt;/strong&gt;，只是为了我自己的需求做了小部分的修改，主要是针对中文适配做的修改。&lt;/p&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加1080P等大屏显示器下的SideBar样式；&lt;/li&gt;
&lt;li&gt;调整文章的样式，比如字体、字体大小、对齐等；&lt;/li&gt;
&lt;li&gt;中英混排自动加入空格（参考 &lt;a href=&quot;https://github.com/vinta/pangu.js&quot;&gt;pangu.js&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;同步更新至 TranquiPeak 1.7.1；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将项目根目录的所有文件复制进一个文件夹，并把该文件夹复制进Hexo项目的themes目录下，再把Hexo的配置文件_config.yml中的theme标签的指改为该文件夹的名称即可。&lt;br&gt;
    
    </summary>
    
      <category term="FrontEnd" scheme="http://kaedea.com/categories/FrontEnd/"/>
    
    
      <category term="Hexo" scheme="http://kaedea.com/tags/Hexo/"/>
    
      <category term="主题" scheme="http://kaedea.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态创建ACTIVITY模式</title>
    <link href="http://kaedea.com/2016/06/14/android-dynamical-loading-07-dynamic-activity/"/>
    <id>http://kaedea.com/2016/06/14/android-dynamical-loading-07-dynamic-activity/</id>
    <published>2016-06-13T16:00:00.000Z</published>
    <updated>2016-06-19T10:55:04.000Z</updated>
    
    <content type="html">&lt;p&gt;还记得我们在代理Activity模式里谈到启动插件APK里的Activity的两个难题吗，由于插件里的Activity没在主项目的Manifest里面注册，所以无法经历系统Framework层级的一系列初始化过程，最终导致获得的Activity实例并没有生命周期和无法使用res资源。&lt;/p&gt;
&lt;p&gt;使用代理Activity能够解决这两个问题，但是有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际运行的Activity实例其实都是ProxyActivity，并不是真正想要启动的Activity；&lt;/li&gt;
&lt;li&gt;ProxyActivity只能指定一种LaunchMode，所以插件里的Activity无法自定义LaunchMode；&lt;/li&gt;
&lt;li&gt;不支持静态注册的BroadcastReceiver；&lt;/li&gt;
&lt;li&gt;往往不是所有的APK都可作为插件被加载，插件项目需要依赖特定的框架，还有需要遵循一定的”开发规范”；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别是最后一个，无法直接把一个普通的APK作为插件使用。这个其实也不算是限制，如果我们需要进行插件化开发，我们总希望能够通过一些框架限制和规范插件的行为，在加载插件前就知道插件大概有哪些功能，这样不仅能方便对插件行为的控制，还能在一定程度上确保插件的安全（运行一个完全未知的可执行文件鬼知道它会做些什么）。不过这样做就要求插件必须依赖特定的框架，这对插件是一种侵入式开发，也就是说，开发插件时不能像开发普通APP那样自由。&lt;/p&gt;
&lt;p&gt;那么有办法避开这些限制，做到完全非侵入式开发吗？比如，通过动态加载框架，不用安装就直接运行《Flappy Bird》的APK安装包。这听起来好像是只有获得ROOT权限才能做到的事情，要不然随便写个空壳的APK加载别人的游戏安装包就直接能运行了。不过，确实有人做到了，通过动态生成Activity类的方式。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态创建Activity模式&quot;&gt;&lt;a href=&quot;#动态创建Activity模式&quot; class=&quot;headerlink&quot; title=&quot;动态创建Activity模式&quot;&gt;&lt;/a&gt;动态创建Activity模式&lt;/h2&gt;&lt;p&gt;插件的Activity不是标准的Activity对象才会有上述的这些限制，使其成为标准的Activity是解决问题的关键，而要使其成为标准的Activity，则需要在主项目里注册这些Activity。总不能把插件APK所有的Activity都事先注册到宿主项目里面吧，想到代理模式需要注册一个代理的ProxyActivity，那么能不能在主项目里 &lt;strong&gt;注册一个通用的Activity&lt;/strong&gt;（比如TargetActivity）给插件里所有的Activity用呢？解决对策就是，在需要启动插件的某一个Activity（比如PlugActivity）的时候，动态创建一个TargetActivity，新创建的TargetActivity会继承PlugActivity的所有共有行为，而这个TargetActivity的包名与类名刚好与我们事先注册的TargetActivity一致，我们就能以标准的方式启动这个Activity。&lt;/p&gt;
&lt;p&gt;运行时动态创建并编译一个Activity类，这种想法不是天方夜谭，动态创建类的工具有&lt;a href=&quot;https://github.com/crittercism/dexmaker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dexmaker&lt;/a&gt;和&lt;a href=&quot;http://asm.ow2.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;asmdex&lt;/a&gt;，二者均能实现动态字节码操作，最大的区别是前者是创建DEX文件，而后者是创建CLASS文件。&lt;/p&gt;
&lt;h2 id=&quot;使用DexMaker动态创建一个类&quot;&gt;&lt;a href=&quot;#使用DexMaker动态创建一个类&quot; class=&quot;headerlink&quot; title=&quot;使用DexMaker动态创建一个类&quot;&gt;&lt;/a&gt;使用DexMaker动态创建一个类&lt;/h2&gt;&lt;p&gt;这种运行时创建一个编译好并能运行的类的方式叫做“动态字节码操作”（runtime bytecode manipulation），使用DexMaker工具能创建一个DEX文件，之后我们再反编译这个DEX看看创建出来的类是什么样子。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AppCompatActivity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		setContentView(R.layout.activity_main);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMakeDex&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View view)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			DexMaker dexMaker = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DexMaker();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;// Generate a HelloWorld class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			TypeId&amp;lt;?&amp;gt; helloWorld = TypeId.get(&lt;span class=&quot;string&quot;&gt;&quot;LHelloWorld;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dexMaker.declare(helloWorld, &lt;span class=&quot;string&quot;&gt;&quot;HelloWorld.generated&quot;&lt;/span&gt;, Modifier.PUBLIC, TypeId.OBJECT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			generateHelloMethod(dexMaker, helloWorld);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;// Create the dex file and load it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			File outputDir = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(Environment.getExternalStorageDirectory() + File.separator + &lt;span class=&quot;string&quot;&gt;&quot;dexmaker&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!outputDir.exists())outputDir.mkdir();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			ClassLoader loader = dexMaker.generateAndLoad(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getClassLoader(), outputDir);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Class&amp;lt;?&amp;gt; helloWorldClass = loader.loadClass(&lt;span class=&quot;string&quot;&gt;&quot;HelloWorld&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;comment&quot;&gt;// Execute our newly-generated code in-process.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			helloWorldClass.getMethod(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;).invoke(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Log.e(&lt;span class=&quot;string&quot;&gt;&quot;MainActivity&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;[onMakeDex]&quot;&lt;/span&gt;,e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 * Generates Dalvik bytecode equivalent to the following method.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *    public static void hello() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        int a = 0xabcd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        int b = 0xaaaa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        int c = a - b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        String s = Integer.toHexString(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        System.out.println(s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 *    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generateHelloMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DexMaker dexMaker, TypeId&amp;lt;?&amp;gt; declaringType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Lookup some types we&#39;ll need along the way.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		TypeId&amp;lt;System&amp;gt; systemType = TypeId.get(System.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		TypeId&amp;lt;PrintStream&amp;gt; printStreamType = TypeId.get(PrintStream.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Identify the &#39;hello()&#39; method on declaringType.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		MethodId hello = declaringType.getMethod(TypeId.VOID, &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Declare that method on the dexMaker. Use the returned Code instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// as a builder that we can append instructions to.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Code code = dexMaker.declare(hello, Modifier.STATIC | Modifier.PUBLIC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Declare all the locals we&#39;ll need up front. The API requires this.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Local&amp;lt;Integer&amp;gt; a = code.newLocal(TypeId.INT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Local&amp;lt;Integer&amp;gt; b = code.newLocal(TypeId.INT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Local&amp;lt;Integer&amp;gt; c = code.newLocal(TypeId.INT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Local&amp;lt;String&amp;gt; s = code.newLocal(TypeId.STRING);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Local&amp;lt;PrintStream&amp;gt; localSystemOut = code.newLocal(printStreamType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// int a = 0xabcd;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.loadConstant(a, &lt;span class=&quot;number&quot;&gt;0xabcd&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// int b = 0xaaaa;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.loadConstant(b, &lt;span class=&quot;number&quot;&gt;0xaaaa&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// int c = a - b;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.op(BinaryOp.SUBTRACT, c, a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// String s = Integer.toHexString(c);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		MethodId&amp;lt;Integer, String&amp;gt; toHexString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				= TypeId.get(Integer.class).getMethod(TypeId.STRING, &lt;span class=&quot;string&quot;&gt;&quot;toHexString&quot;&lt;/span&gt;, TypeId.INT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.invokeStatic(toHexString, s, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// System.out.println(s);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		FieldId&amp;lt;System, PrintStream&amp;gt; systemOutField = systemType.getField(printStreamType, &lt;span class=&quot;string&quot;&gt;&quot;out&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.sget(systemOutField, localSystemOut);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		MethodId&amp;lt;PrintStream, Void&amp;gt; printlnMethod = printStreamType.getMethod(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				TypeId.VOID, &lt;span class=&quot;string&quot;&gt;&quot;println&quot;&lt;/span&gt;, TypeId.STRING);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.invokeVirtual(printlnMethod, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, localSystemOut, s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// return;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		code.returnVoid();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行后在SD卡的dexmaker目录下找到刚创建的文件“Generated1532509318.jar”，把里面的“classes.dex”解压出来，然后再用“dex2jar”工具转化成jar文件，最后再用“jd-gui”工具反编译jar的源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-12-1/15858284.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经成功在运行时创建一个编译好的类（的DEX）。&lt;/p&gt;
&lt;h2 id=&quot;修改需要启动的目标Activity&quot;&gt;&lt;a href=&quot;#修改需要启动的目标Activity&quot; class=&quot;headerlink&quot; title=&quot;修改需要启动的目标Activity&quot;&gt;&lt;/a&gt;修改需要启动的目标Activity&lt;/h2&gt;&lt;p&gt;接下来的问题是如何把需要启动的、在Manifest里面没有注册的PlugActivity换成有注册的TargetActivity。&lt;/p&gt;
&lt;p&gt;在Android，虚拟机加载类的时候，是通过ClassLoader的loadClass方法，而loadClass方法并不是final类型的，这意味着我们可以创建自己的类去继承ClassLoader，以重载loadClass方法并改写类的加载逻辑，在需要加载PlugActivity的时候，偷偷把其换成TargetActivity。&lt;/p&gt;
&lt;p&gt;大致思路如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CJClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassLoader&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class &lt;span class=&quot;title&quot;&gt;loadClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String className)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(当前上下文插件不为空) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( className 是 TargetActivity)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             找到当前实际要加载的原始PlugActivity，动态创建类（TargetActivity extends PlugActivity ）的dex文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  从dex文件中加载的TargetActivity&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  使用对应的PluginClassLoader加载普通类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.loadClass() &lt;span class=&quot;comment&quot;&gt;//使用原来的类加载方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样就能把启动插件里的PlugActivity变成启动动态创建的TargetActivity。&lt;/p&gt;
&lt;p&gt;不过还有一个问题，主项目启动插件Activity的时候，我们可以替换Activity，但是如果在插件Activity（比如MainActivity）启动另一个Activity（SubActivity）的时候怎么办？插件时普通的第三方APK，我们无法更改里面跳转Activity的逻辑。其实，从主项目启动插件MainActivity的时候，其实启动的是我们动态创建的TargetActivity（extends MainActivity），而我们知道Activity启动另一个Activity的时候都是使用其“startActivityForResult”方法，所以我们可以在创建TargetActivity时，重写其“startActivityForResult”方法，让它在启动其他Activity的时候，也采用动态创建Activity的方式，这样就能解决问题。&lt;/p&gt;
&lt;h2 id=&quot;动态创建Activity开源项目-android-pluginmgr&quot;&gt;&lt;a href=&quot;#动态创建Activity开源项目-android-pluginmgr&quot; class=&quot;headerlink&quot; title=&quot;动态创建Activity开源项目 android-pluginmgr&quot;&gt;&lt;/a&gt;动态创建Activity开源项目 &lt;a href=&quot;https://github.com/houkx/android-pluginmgr/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-pluginmgr&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这种脑洞大开的动态加载思路来自于 &lt;strong&gt;houkx&lt;/strong&gt; 的开源项目 &lt;strong&gt;android-pluginmgr&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-12-1/6260656.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android-pluginmgr&lt;/code&gt;项目中有三种ClassLoader，一是用于替换宿主APK的Application的&lt;code&gt;CJClassLoader&lt;/code&gt;，二是用于加载插件APK的&lt;code&gt;PluginClassLoader&lt;/code&gt;，再来是用于加载启动插件Activity时动态生成的PlugActivity的dex包的&lt;code&gt;DexClassLoader&lt;/code&gt;（存放在Map集合&lt;code&gt;proxyActivityLoaderMap&lt;/code&gt;里面）。其中&lt;code&gt;CJClassLoader&lt;/code&gt;是&lt;code&gt;PluginClassLoader&lt;/code&gt;的Parent，而&lt;code&gt;PluginClassLoader&lt;/code&gt;又是第三种&lt;code&gt;DexClassLoader&lt;/code&gt;的Parent。&lt;/p&gt;
&lt;p&gt;ClassLoader类加载Class的时候，会先使用Parent的&lt;code&gt;ClassLoader&lt;/code&gt;，但Parent不能完成加载工作时，才会调用Child的&lt;code&gt;ClassLoader&lt;/code&gt;去完成工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.ClassLoader&lt;br&gt;Loads classes and resources from a repository. One or more class loaders are installed at runtime. These are consulted whenever the runtime system needs a specific class that is not yet available in-memory. Typically, class loaders are grouped into a tree where child class loaders delegate all requests to parent class loaders. Only if the parent class loader cannot satisfy the request, the child class loader itself tries to handle it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体分析请参考 &lt;a href=&quot;http://segmentfault.com/a/1190000004062880&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载基础 ClassLoader的工作机制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;所以每加载一个Activity的时候都会调用到最上级的&lt;code&gt;CJClassLoader&lt;/code&gt;的&lt;code&gt;loadClass&lt;/code&gt;方法，从而保证启动插件Activity的时候能顺利替换成PlugActivity。当然如何控制着三种ClassLoader的加载工作，也是&lt;code&gt;pluginmgr&lt;/code&gt;项目的设计难度之一。&lt;/p&gt;
&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;动态类创建的方式，使得注册一个通用的Activity就能给多给Activity使用，对这种做法存在的问题也是明显的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用同一个注册的Activity，所以一些需要在Manifest注册的属性无法做到每个Activity都自定义配置；&lt;/li&gt;
&lt;li&gt;插件中的权限，无法动态注册，插件需要的权限都得在宿主中注册，无法动态添加权限；&lt;/li&gt;
&lt;li&gt;插件的Activity无法开启独立进程，因为这需要在Manifest里面注册；&lt;/li&gt;
&lt;li&gt;动态字节码操作涉及到Hack开发，所以相比代理模式起来不稳定；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中不稳定的问题出现在对Service的支持上，使用动态创建类的方式可以搞定Activity和Broadcast Receiver，但是使用类似的方式处理Service却不行，因为“ContextImpl.getApplicationContext” 期待得到一个非ContextWrapper的context，如果不是则继续下次循环，目前的Context实例都是wrapper，所以会进入死循环。&lt;/p&gt;
&lt;p&gt;据 &lt;strong&gt;houkx&lt;/strong&gt; 称他现在有另外的思路实现“启动为安装的普通第三方APK”的目的，而且不是基于动态类创建的原理，期待他的开源项目的更新。&lt;/p&gt;
&lt;h2 id=&quot;代理Activity模式与动态创建Activity模式的区别&quot;&gt;&lt;a href=&quot;#代理Activity模式与动态创建Activity模式的区别&quot; class=&quot;headerlink&quot; title=&quot;代理Activity模式与动态创建Activity模式的区别&quot;&gt;&lt;/a&gt;代理Activity模式与动态创建Activity模式的区别&lt;/h2&gt;&lt;p&gt;简单地说，最大的不同是代理模式使用了一个 &lt;strong&gt;代理的Activity&lt;/strong&gt;，而动态创建Activity模式使用了一个 &lt;strong&gt;通用的Activity&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代理模式中，使用一个代理Activity去完成本应该由插件Activity完成的工作，这个代理Activity是一个标准的Android Activity组件，具有生命周期和上下文环境（ContextWrapper和ContextCompl），但是它自身只是一个空壳，并没有承担什么业务逻辑；而插件Activity其实只是一个普通的Java对象，它没有上下文环境，但是却能正常执行业务逻辑的代码。代理Activity和不同的插件Activity配合起来，就能完成不同的业务逻辑了。所以代理模式其实还是使用常规的Android开发技术，只是在处理插件资源的时候强制调用了系统的隐藏API（除非某些ROM蛋疼修改了这个API），因此这种模式还是可以稳定工作和升级的。&lt;/p&gt;
&lt;p&gt;动态创建Activity模式，被动态创建出来的Activity类是有在主项目里面注册的，它是一个标准的Activity，它有自己的Context和生命周期，不需要代理的Activity。&lt;/p&gt;
&lt;p&gt;(这个系列的下个文章开始介绍插件化框架“Android Frontia”的设计和开发过程。)&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/hkxxx/article/details/42194387&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/hkxxx/article/details/42194387&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;还记得我们在代理Activity模式里谈到启动插件APK里的Activity的两个难题吗，由于插件里的Activity没在主项目的Manifest里面注册，所以无法经历系统Framework层级的一系列初始化过程，最终导致获得的Activity实例并没有生命周期和无法使用res资源。&lt;/p&gt;
&lt;p&gt;使用代理Activity能够解决这两个问题，但是有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际运行的Activity实例其实都是ProxyActivity，并不是真正想要启动的Activity；&lt;/li&gt;
&lt;li&gt;ProxyActivity只能指定一种LaunchMode，所以插件里的Activity无法自定义LaunchMode；&lt;/li&gt;
&lt;li&gt;不支持静态注册的BroadcastReceiver；&lt;/li&gt;
&lt;li&gt;往往不是所有的APK都可作为插件被加载，插件项目需要依赖特定的框架，还有需要遵循一定的”开发规范”；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别是最后一个，无法直接把一个普通的APK作为插件使用。这个其实也不算是限制，如果我们需要进行插件化开发，我们总希望能够通过一些框架限制和规范插件的行为，在加载插件前就知道插件大概有哪些功能，这样不仅能方便对插件行为的控制，还能在一定程度上确保插件的安全（运行一个完全未知的可执行文件鬼知道它会做些什么）。不过这样做就要求插件必须依赖特定的框架，这对插件是一种侵入式开发，也就是说，开发插件时不能像开发普通APP那样自由。&lt;/p&gt;
&lt;p&gt;那么有办法避开这些限制，做到完全非侵入式开发吗？比如，通过动态加载框架，不用安装就直接运行《Flappy Bird》的APK安装包。这听起来好像是只有获得ROOT权限才能做到的事情，要不然随便写个空壳的APK加载别人的游戏安装包就直接能运行了。不过，确实有人做到了，通过动态生成Activity类的方式。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态创建Activity" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAActivity/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>双屏显示器配合机械键盘食用更佳</title>
    <link href="http://kaedea.com/2016/06/11/tool-duplicate-screen-and-mechanical-keyboard/"/>
    <id>http://kaedea.com/2016/06/11/tool-duplicate-screen-and-mechanical-keyboard/</id>
    <published>2016-06-10T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/92530699.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直计划着打造自己的工作室（工作平台），因为我觉得除了相关姿势扎实以外，优秀的生产工具也是提高办公效率的利器，而且好玩的生产工具还能提高自己工作的积极性，减少咸鱼状态。所以，适当地买一些优质的生产工具犒劳自己，也是我自己为数不多的乐趣。说到开发相关的生产工具，则莫过于大屏显示器和机械键盘了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;双屏显示器&quot;&gt;&lt;a href=&quot;#双屏显示器&quot; class=&quot;headerlink&quot; title=&quot;双屏显示器&quot;&gt;&lt;/a&gt;双屏显示器&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/76330000.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;写代码的时候，我们当然希望编辑器越大越好，但是IDE自身就有几个分区，除了Editor之外，还有Project、Log、Debug等窗口，所以Editor所占的区域并不多，如果电脑屏幕本身尺寸就小的话，就得在多个窗口之间来回切换。而且，开发过程中不止需要写代码，还要看文档，看设计图，上Google查资料，那不仅IDE自身，我们还得在多个工具之间来回切换。一开始我也觉得没什么，只要熟练了就习惯了，但后来我觉得，解决这些经常需要重复的繁琐动作，是提高作业效率的有效办法，所以便开始琢磨着大屏幕的问题。&lt;/p&gt;
&lt;p&gt;一开始我打算买一个2K的大屏显示器，这样可以在桌面上放多个窗口，不过这个时间段2K的显示器的选择可不多（基本也就DELL和AOC家的），而且性价比不咋滴（囊中羞涩），最主要的，如果只使用一个2K的显示器，原本的显示器就得闲置了，所以我选择了双屏的方案。&lt;/p&gt;
&lt;p&gt;其实我更喜欢“双屏显示器+显示器支架”的方案，只不过我的办公位空间不够，所以选择了一横一竖的折中方案。刚好手头有一个急着上线的需求，多显示器的魅力一下子就彰显出来。我基本保持着“一个屏幕写代码，一个屏幕看文档”的姿势做完了这个需求，只能说这种感觉比我想象中的要好，有种中毒上瘾的感觉，这时候我实在感叹“在办公方面能剁手就剁手”这一道理了。我觉得我再也离不开多屏显示器了，立刻在我的“工作平台企画”上加上了“双屏显示器”这一个ITEM。&lt;/p&gt;
&lt;h4 id=&quot;机械键盘&quot;&gt;&lt;a href=&quot;#机械键盘&quot; class=&quot;headerlink&quot; title=&quot;机械键盘&quot;&gt;&lt;/a&gt;机械键盘&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/75016346.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机械键盘对我的吸引力就不再强调了，上个月在日亚买了个FLICO忍者青轴，这是我第二个机械键盘，用了一个月感觉还不错，最近也给其换上了ABS键帽，相比彩虹浸染之类的，我比较喜欢大二色的主题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/80025296.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我选的这个键盘是“百合丁香”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/6339173.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于机械键盘轴体的选择，有这么一个流传的段子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　　青轴像少女，夹的紧，下去的时候需要用些力气，深浅你都能感觉得到，虽然叫声很大，总体给人感觉确很兴奋。&lt;br&gt;&lt;br&gt;　　茶轴像少妇，虽然比少女的要松，但很容易下去，而且仔细感觉也能体会到深浅，叫声没有少女那个清脆，但却更趋近于性感的中音，总体给人感觉十分舒畅。&lt;br&gt;&lt;br&gt;　　红轴像泼妇，虽然松，下去的时候不需要太用力就能到见底，插一点爽深插更爽，虽然插到底才有一点声音，但是玩起来很有感觉，让人有种玩了一下还想玩第二下的赶脚！&lt;br&gt;&lt;br&gt;　　黑轴像妓女玩起来很带劲，可以放心的用力插，很少能插到底，力气大它就有叫声，但是插多了你会觉得累！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;青轴自然是我的首选（我比较喜欢青蓝色 🌝），那清脆的“啪啪啪”的打击感我早已喜欢上。不过青轴比较适合打字，而茶轴比较符合Geek（忘了从哪听来的说法），而同事的茶轴键盘我用起来感觉手感也挺不错的，刚好我宿舍缺一个键盘（周末把键盘背回家的就我一个么），所以接下来打算入手一个67键位的茶轴键盘（是不是打开了剁手的新世界啊）。&lt;/p&gt;
&lt;!-- last edit --&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/92530699.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直计划着打造自己的工作室（工作平台），因为我觉得除了相关姿势扎实以外，优秀的生产工具也是提高办公效率的利器，而且好玩的生产工具还能提高自己工作的积极性，减少咸鱼状态。所以，适当地买一些优质的生产工具犒劳自己，也是我自己为数不多的乐趣。说到开发相关的生产工具，则莫过于大屏显示器和机械键盘了。&lt;br&gt;
    
    </summary>
    
      <category term="生产工具" scheme="http://kaedea.com/categories/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="显示器" scheme="http://kaedea.com/tags/%E6%98%BE%E7%A4%BA%E5%99%A8/"/>
    
      <category term="机械键盘" scheme="http://kaedea.com/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"/>
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>代理ACTIVITY模式</title>
    <link href="http://kaedea.com/2016/06/10/android-dynamical-loading-06-proxy-activity/"/>
    <id>http://kaedea.com/2016/06/10/android-dynamical-loading-06-proxy-activity/</id>
    <published>2016-06-09T16:00:00.000Z</published>
    <updated>2016-06-19T06:17:15.000Z</updated>
    
    <content type="html">&lt;p&gt;简单模式中，使用ClassLoader加载外部的Dex或Apk文件，可以加载一些本地APP不存在的类（或者更新本地已存在的类），从而执行一些新的代码逻辑，但是使用这种方法却不能直接启动插件里的Activity等组件，也没办法使用res资源，如果不解决这两个问题，则使用插件化的方式开发Android业务会非常繁琐。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;启动没有注册的Activity的两个主要问题&quot;&gt;&lt;a href=&quot;#启动没有注册的Activity的两个主要问题&quot; class=&quot;headerlink&quot; title=&quot;启动没有注册的Activity的两个主要问题&quot;&gt;&lt;/a&gt;启动没有注册的Activity的两个主要问题&lt;/h2&gt;&lt;p&gt;Activity等组件是需要在Manifest中注册后才能以标准Intent的方式启动的（如果有兴趣强烈推荐你了解下AMS和Activity生命周期实现的机制），简单来说，通过ClassLoader加载并实例化的Activity实例只是一个普通的Java对象，能调用对象的方法，但是它没有生命周期，而且Activity等系统组件是需要Android的上下文环境的（也就是我们常说的Context），没有这些东西Activity根本无法工作。&lt;/p&gt;
&lt;p&gt;使用插件APK里的Activity需要解决 &lt;strong&gt;两个问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何使插件APK里的Activity具有生命周期；&lt;/li&gt;
&lt;li&gt;如何使插件APK里的Activity具有上下文环境（使用res资源）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代理Activity模式为解决这两个问题提供了一种思路。&lt;/p&gt;
&lt;h2 id=&quot;代理Activity模式&quot;&gt;&lt;a href=&quot;#代理Activity模式&quot; class=&quot;headerlink&quot; title=&quot;代理Activity模式&quot;&gt;&lt;/a&gt;代理Activity模式&lt;/h2&gt;&lt;p&gt;这种模式也是我们项目中，继“简单动态加载模式”之后，第二种投入实际生产项目的开发方式。其主要思路是：主项目APK注册一个代理Activity（比如命名为ProxyActivity），ProxyActivity是一个普通的Activity，但只是一个空壳，自身并没有什么业务逻辑。每次打开插件APK里的某一个Activity的时候，都是在主项目里使用标准的方式启动ProxyActivity，再在ProxyActivity的生命周期里同步调用插件中的Activity实例的生命周期方法，从而执行插件APK的业务逻辑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ProxyActivity + 没注册的Activity = 标准的Activity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面谈谈代理模式是怎么处理上面提到的两个问题的。&lt;/p&gt;
&lt;h3 id=&quot;1-处理插件Activity的生命周期&quot;&gt;&lt;a href=&quot;#1-处理插件Activity的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1. 处理插件Activity的生命周期&quot;&gt;&lt;/a&gt;1. 处理插件Activity的生命周期&lt;/h3&gt;&lt;p&gt;如果不使用任何注入的方式干预ActivityManagerService启动Activity的过程，目前还真的没什么办法能够处理这个问题。一个Activity的启动，如果不采用标准的Intent方式，没有经历过AMS的一系列注册和初始化过程，它的生命周期方法是不会被系统调用的（除非你能够修改Android系统的一些代码，而这已经是另一个领域的话题了，这里不展开）。&lt;/p&gt;
&lt;p&gt;那把插件APK里所有Activity都注册到主项目的Manifest里，再以标准Intent方式启动，这样插件的Activity就能工作了。但是事先主项目并不知道插件Activity里会新增哪些Activity，如果每次有新加的Activity都需要升级主项目的版本，那不是本末倒置了，不如把插件的逻辑直接写到主项目里来得方便，所以事先注册Activity组件的做法只适合于Activity不多变的业务。&lt;/p&gt;
&lt;p&gt;那就绕绕弯吧，生命周期不就是系统对Activity一些特定接口方法的调用嘛，那我们可以在主项目里创建一个ProxyActivity，再由它去代理调用插件Activity的生命周期方法（熟悉设计模式的同学应该知道这种写法叫做代理模式，这也是我代理Activity模式叫法的由来）。&lt;/p&gt;
&lt;p&gt;用ProxyActivity（一个标准的Activity实例）的生命周期同步控制插件Activity（普通类的实例）的生命周期，同步的方式可以有下面两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在ProxyActivity生命周期里用反射调用插件Activity相应生命周期的方法，简单粗暴；&lt;/li&gt;
&lt;li&gt;把插件Activity的生命周期抽象成接口，在ProxyActivity的生命周期里调用；另外，多了这一层接口，也方便主项目控制插件Activity；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里补充说明下，Fragment自带生命周期，用Fragment来代替Activity开发可以省去大部分生命周期的控制工作，但是会使得界面跳转比较麻烦。&lt;/p&gt;
&lt;h3 id=&quot;2-在插件Activity里使用res资源&quot;&gt;&lt;a href=&quot;#2-在插件Activity里使用res资源&quot; class=&quot;headerlink&quot; title=&quot;2. 在插件Activity里使用res资源&quot;&gt;&lt;/a&gt;2. 在插件Activity里使用res资源&lt;/h3&gt;&lt;p&gt;使用代理的方式同步调用生命周期的做法容易理解，也没什么问题，但是要使用插件里面的res资源就有点麻烦了。简单的说，res里的每一个资源都会在R.java里生成一个对应的Integer类型的id，APP启动时会先把R.java注册到当前的上下文环境，我们在代码里以R文件的方式使用资源时正是通过使用这些id访问res资源，然而插件的R.java并没有注册到当前的上下文环境，所以插件的res资源也就无法通过id使用了。&lt;/p&gt;
&lt;p&gt;这个问题困扰了我们很久，一开始的项目急于投入生产，所以我们索性抛开res资源，插件里需要用到的新资源都通过纯Java代码的方式创建（包括XML布局、动画、点九图等），蛋疼但有效。直到网上出现了解决这一个问题的有效方法（一开始貌似是在手机QQ项目中出现的，但是没有开源所以不清楚，在这里真的佩服这些对技术这么有追求的开发者）。&lt;/p&gt;
&lt;p&gt;记得我们平时怎么使用res资源的吗，就是“getResources().getXXX(resid)”，看看“getResources()”&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Resources &lt;span class=&quot;title&quot;&gt;getResources&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mResources != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mOverrideConfiguration == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mResources = &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.getResources();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Context resc = createConfigurationContext(mOverrideConfiguration);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mResources = resc.getResources();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看起来像是通过mResources实例获取res资源的，再找找mResources实例是怎么初始化的，看看上面的代码发现是使用了super类ContextThemeWrapper里的“getResources()”方法，看进去&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Context mBase;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ContextWrapper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context base)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mBase = base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Resources &lt;span class=&quot;title&quot;&gt;getResources&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mBase.getResources();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看样子又调用了Context的“getResources()”方法，看到这里，熟悉Java的我们应该知道Context只是个抽象类，其实际工作都是在ContextImpl完成的，赶紧去ContextImpl里看看“getResources()”方法吧&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Resources &lt;span class=&quot;title&quot;&gt;getResources&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;…………&lt;br&gt;……&lt;/p&gt;
&lt;p&gt;你TM在逗我么，还是没有mResources的创建过程啊！啊，不对，mResources是ContextImpl的成员变量，可能是在构造方法中创建的，赶紧去看看构造方法（这里只给出关键代码）。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        overrideConfiguration, compatInfo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mResources = resources;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看样子是在ResourcesManager的“getTopLevelResources”方法中创建的，看进去&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Resources &lt;span class=&quot;title&quot;&gt;getTopLevelResources&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String resDir, String[] splitResDirs,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           String[] overlayDirs, String[] libDirs, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; displayId,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           Configuration overrideConfiguration, CompatibilityInfo compatInfo)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Resources r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       AssetManager assets = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AssetManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (libDirs != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String libDir : libDirs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (libDir.endsWith(&lt;span class=&quot;string&quot;&gt;&quot;.apk&quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (assets.addAssetPath(libDir) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       Log.w(TAG, &lt;span class=&quot;string&quot;&gt;&quot;Asset path &#39;&quot;&lt;/span&gt; + libDir +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                               &lt;span class=&quot;string&quot;&gt;&quot;&#39; does not exist or contains no resources.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       DisplayMetrics dm = getDisplayMetricsLocked(displayId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       Configuration config ……;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       r = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Resources(assets, dm, config, compatInfo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看来这里是关键了，看样子就是通过这些代码从一个APK文件加载res资源并创建Resources实例，经过这些逻辑后就可以使用R文件访问资源了。具体过程是，获取一个AssetManager实例，使用其“addAssetPath”方法加载APK（里的资源），再使用DisplayMetrics、Configuration、CompatibilityInfo实例一起创建我们想要的Resources实例。&lt;/p&gt;
&lt;p&gt;最终访问插件APK里res资源的关键代码如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AssetManager assetManager = AssetManager.class.newInstance();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method addAssetPath = assetManager.getClass().getMethod(&lt;span class=&quot;string&quot;&gt;&quot;addAssetPath&quot;&lt;/span&gt;, String.class);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addAssetPath.invoke(assetManager, mDexPath);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mAssetManager = assetManager;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e.printStackTrace();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Resources superRes = &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.getResources();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mResources = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Resources(mAssetManager, superRes.getDisplayMetrics(),  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        superRes.getConfiguration());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意，有的人担心从插件APK加载进来的res资源的ID可能与主项目里现有的资源ID冲突，其实这种方式加载进来的res资源并不是融入到主项目里面来，主项目里的res资源是保存在ContextImpl里面的Resources实例，整个项目共有，而新加进来的res资源是保存在新创建的Resources实例的，也就是说ProxyActivity其实有两套res资源，并不是把新的res资源和原有的res资源合并了（所以不怕R.id重复），&lt;strong&gt;对两个res资源的访问都需要用对应的Resources实例&lt;/strong&gt;，这也是开发时要处理的问题。（其实应该有3套，Android系统会加载一套framework-res.apk资源，里面存放系统默认Theme等资源。）&lt;/p&gt;
&lt;p&gt;额外补充下，这里你可能注意到了我们采用了反射的方法调用AssetManager的“addAssetPath”方法，而在上面ResourcesManager中调用AssetManager的“addAssetPath”方法是直接调用的，不用反射啊，而且看看SDK里AssetManager的“addAssetPath”方法的源码（这里也能看到具体APK资源的提取过程是在Native里完成的），发现它也是public类型的，外部可以直接调用，为什么还要用反射呢？&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Add an additional set of assets to the asset manager.  This can be&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * either a directory or ZIP file.  Not for use by applications.  Returns&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * the cookie of the added asset, or 0 on failure.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@hide&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addAssetPath&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String path)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = addAssetPathNative(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        makeStringBlocks(mStringBlocks);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里有个误区，SDK的源码只是给我们参考用的，APP实际上运行的代码逻辑在android.jar里面（位于android-sdk\platforms\android-XX），反编译android.jar并找到ResourcesManager类就可以发现这些接口都是对应用层隐藏的。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AssetManager&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  AssetManager()&amp;#123;&lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; InputStream &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; InputStream &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String fileName, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; accessMode)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AssetFileDescriptor &lt;span class=&quot;title&quot;&gt;openFd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String[] list(String paramString) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AssetFileDescriptor &lt;span class=&quot;title&quot;&gt;openNonAssetFd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; AssetFileDescriptor &lt;span class=&quot;title&quot;&gt;openNonAssetFd&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cookie, String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; XmlResourceParser &lt;span class=&quot;title&quot;&gt;openXmlResourceParser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; XmlResourceParser &lt;span class=&quot;title&quot;&gt;openXmlResourceParser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cookie, String fileName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finalize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; String[] getLocales();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到此，启动插件里的Activity的两大问题都有解决的方案了。&lt;/p&gt;
&lt;h2 id=&quot;代理模式的具体项目-dynamic-load-apk&quot;&gt;&lt;a href=&quot;#代理模式的具体项目-dynamic-load-apk&quot; class=&quot;headerlink&quot; title=&quot;代理模式的具体项目 dynamic-load-apk&quot;&gt;&lt;/a&gt;代理模式的具体项目 &lt;a href=&quot;https://github.com/singwhatiwanna/dynamic-load-apk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dynamic-load-apk&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;上面只是分析了代理模式的关键技术点，如果运用到具体项目中去的话，除了两个关键的问题外，还有许多繁琐的细节需要处理，我们需要设计一个框架，规范插件APK项目的开发，也方便以后功能的扩展。&lt;/p&gt;
&lt;p&gt;这里，&lt;strong&gt;dynamic-load-apk&lt;/strong&gt; 向我们展示了许多优秀的处理方法，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把Activity关键的生命周期方法抽象成DLPlugin接口，ProxyActivity通过DLPlugin代理调用插件Activity的生命周期；&lt;/li&gt;
&lt;li&gt;设计一个基础的BasePluginActivity类，插件项目里使用这些基类进行开发，可以以接近常规Android开发的方式开发插件项目；&lt;/li&gt;
&lt;li&gt;以类似的方式处理Service的问题；&lt;/li&gt;
&lt;li&gt;处理了大量常见的兼容性问题（比如使用Theme资源时出现的问题）；&lt;/li&gt;
&lt;li&gt;处理了插件项目里的so库的加载问题；&lt;/li&gt;
&lt;li&gt;使用PluginPackage管理插件APK，从而可以方便地管理多个插件项目；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;处理插件项目里的so库的加载&quot;&gt;&lt;a href=&quot;#处理插件项目里的so库的加载&quot; class=&quot;headerlink&quot; title=&quot;处理插件项目里的so库的加载&quot;&gt;&lt;/a&gt;处理插件项目里的so库的加载&lt;/h3&gt;&lt;p&gt;这里需要把插件APK里面的SO库文件解压释放出来，在根据当前设备CPU的型号选择对应的SO库，并使用System.load方法加载到当前内存中来，具体分析请参考 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/21303038&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载补充 加载SD卡的SO库&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;多插件APK的管理&quot;&gt;&lt;a href=&quot;#多插件APK的管理&quot; class=&quot;headerlink&quot; title=&quot;多插件APK的管理&quot;&gt;&lt;/a&gt;多插件APK的管理&lt;/h3&gt;&lt;p&gt;动态加载一个插件APK需要三个对应的&lt;code&gt;DexClassLoader&lt;/code&gt;、&lt;code&gt;AssetManager&lt;/code&gt;、&lt;code&gt;Resources&lt;/code&gt;实例，可以用组合的方式创建一个&lt;code&gt;PluginPackage&lt;/code&gt;类存放这三个变量，再创建一个管理类&lt;code&gt;PluginManager&lt;/code&gt;，用成员变量&lt;code&gt;HashMap&amp;lt;dexPath,pluginPackage&amp;gt;&lt;/code&gt;的方式保存&lt;code&gt;PluginPackage&lt;/code&gt;实例。&lt;/p&gt;
&lt;p&gt;具体的代码请参考原项目的文档、源码以及Sample里面的示例代码，在这里感谢&lt;a href=&quot;https://github.com/singwhatiwanna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;singwhatiwanna&lt;/a&gt;的开源精神。&lt;/p&gt;
&lt;h2 id=&quot;实际应用中可能要处理的问题&quot;&gt;&lt;a href=&quot;#实际应用中可能要处理的问题&quot; class=&quot;headerlink&quot; title=&quot;实际应用中可能要处理的问题&quot;&gt;&lt;/a&gt;实际应用中可能要处理的问题&lt;/h2&gt;&lt;h3 id=&quot;1-插件APK的管理后台&quot;&gt;&lt;a href=&quot;#1-插件APK的管理后台&quot; class=&quot;headerlink&quot; title=&quot;1. 插件APK的管理后台&quot;&gt;&lt;/a&gt;1. 插件APK的管理后台&lt;/h3&gt;&lt;p&gt;使用动态加载的目的，就是希望可以绕过APK的安装过程升级应用的功能，如果插件APK是打包在主项目内部的那动态加载纯粹是多次一举。更多的时候我们希望可以在线下载插件APK，并且在插件APK有新版本的时候，主项目要从服务器下载最新的插件替换本地已经存在的旧插件。为此，我们应该有一个管理后台，它大概有以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上传不同版本的插件APK，并向APP主项目提供插件APK信息查询功能和下载功能；&lt;/li&gt;
&lt;li&gt;管理在线的插件APK，并能向不同版本号的APP主项目提供最合适的插件APK；&lt;/li&gt;
&lt;li&gt;万一最新的插件APK出现紧急BUG，要提供旧版本回滚吊销功能；&lt;/li&gt;
&lt;li&gt;如果旧版本的插件在有严重BUG，则需要平台提供强制升级功能；&lt;/li&gt;
&lt;li&gt;出于安全考虑应该对APP项目的请求信息做一些安全性校验；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-插件APK合法性校验&quot;&gt;&lt;a href=&quot;#2-插件APK合法性校验&quot; class=&quot;headerlink&quot; title=&quot;2. 插件APK合法性校验&quot;&gt;&lt;/a&gt;2. 插件APK合法性校验&lt;/h3&gt;&lt;p&gt;加载外部的可执行代码，一个逃不开的问题就是要确保外部代码的安全性，我们可不希望加载一些来历不明的插件APK，因为这些插件有的时候能访问主项目的关键数据。&lt;/p&gt;
&lt;p&gt;最简单可靠的做法就是校验插件APK的MD5值，如果插件APK的MD5与我们服务器预置的数值不同，就认为插件被改动过，弃用。当然最好是方式是校验插件APK的签名，因为插件是APK文件，本身就带有签名信息，如果插件被修改过，签名信息就会变动，我觉得这是检验插件合法性最好的办法。&lt;/p&gt;
&lt;h2 id=&quot;是热部署，还是插件化？&quot;&gt;&lt;a href=&quot;#是热部署，还是插件化？&quot; class=&quot;headerlink&quot; title=&quot;是热部署，还是插件化？&quot;&gt;&lt;/a&gt;是热部署，还是插件化？&lt;/h2&gt;&lt;p&gt;这一部分作为补充说明，如果不太熟悉动态加载的使用姿势，可能不是那么容易理解。&lt;/p&gt;
&lt;p&gt;谈到动态加载的时候我们经常说到“热部署”和“插件化”这些名词，它们虽然都和动态加载有关，但是还是有一点区别，这个问题涉及到主项目与插件项目的 &lt;strong&gt;交互方式&lt;/strong&gt;。前面我们说到，动态加载方式，可以在“项目层级”做到代码分离，按道理我们希望是主项目和插件项目不要有任何交互行为，实际上也应该如此！这样做不仅能确保项目的安全性，也能简化开发工作，所以一般的做法是：&lt;/p&gt;
&lt;h3 id=&quot;1-只有在用户使用到的时候才加载插件&quot;&gt;&lt;a href=&quot;#1-只有在用户使用到的时候才加载插件&quot; class=&quot;headerlink&quot; title=&quot;1. 只有在用户使用到的时候才加载插件&quot;&gt;&lt;/a&gt;1. 只有在用户使用到的时候才加载插件&lt;/h3&gt;&lt;p&gt;主项目还是像常规Android项目那样开发，只有用户使用插件APK的功能时才动态加载插件并运行，插件一旦运行后，与主项目没有任何交互逻辑，只有在主项目启动插件的时候才触发一次调用插件的行为。比如，我们的主项目里有几款推广的游戏，平时在用户使用主项目的功能时，可以先静默把游戏（其实就是一个插件APK）下载好，当用户点击游戏入口时，以动态加载的方式启动游戏，游戏只运行插件APK里的代码逻辑，结束后返回主项目界面。&lt;/p&gt;
&lt;h3 id=&quot;2-一启动主项目就加载插件&quot;&gt;&lt;a href=&quot;#2-一启动主项目就加载插件&quot; class=&quot;headerlink&quot; title=&quot;2. 一启动主项目就加载插件&quot;&gt;&lt;/a&gt;2. 一启动主项目就加载插件&lt;/h3&gt;&lt;p&gt;另外一种完全相反的情形是，主项目只提供一个启动的入口，以及从服务器下载最新插件的更新逻辑，这两部分的代码都是长期保持不变的，应用一启动就动态加载插件，所有业务逻辑的代码都在插件里实现。比如现在一些游戏市场都要求开发者接入其SDK项目，如果SDK项目采用这种开发方式，先提供一个空壳的SDK给开发者，空壳SDK能从服务器下载最新的插件再运行插件里的逻辑，就能保证开发者开发的游戏每次启动的时候都能运行最新的代码逻辑，而不用让开发者在SDK有新版本的时候重新更换SDK并构建新的游戏APK。&lt;/p&gt;
&lt;h3 id=&quot;3-让插件使用主项目的功能&quot;&gt;&lt;a href=&quot;#3-让插件使用主项目的功能&quot; class=&quot;headerlink&quot; title=&quot;3. 让插件使用主项目的功能&quot;&gt;&lt;/a&gt;3. 让插件使用主项目的功能&lt;/h3&gt;&lt;p&gt;有些时候，比如，主项目里有一个成熟的图片加载框架ImageLoader，而插件里也有一个ImageLoader。如果一个应用同时运行两套ImageLoader，那会有许多额外的性能开销，如果能让插件也用主项目的ImageLoader就好了。另外，如果在插件里需要用到用户登录功能，我们总不希望用户使用主项目时进行一次登录，进入插件时由来一次登录，如果能在插件里使用主项目的登录状态就好了。&lt;/p&gt;
&lt;p&gt;因此，有些时候我们希望插件项目能调用主项目的功能。怎么处理好呢，由于插件项目与主项目是分开的，我们在开发插件的时候，怎么调用主项目的代码啊？这里需要稍微了解一下Android项目间的依赖方式。&lt;/p&gt;
&lt;p&gt;想想一个普通的APK是怎么构建和运行的，Android SDK提供了许多系统类（如Activity、Fragment等，一般我们也喜欢在这里查看源码），我们的Android项目依赖Android SDK项目并使用这些类进行开发，那构建APK的时候会把这些类打包进来吗？不会，要是每个APK都打包一份，那得有多少冗余啊。所以Android项目至少有两种依赖的方式，一种构建时会把被依赖的项目（Library）的类打包进来，一种不会。&lt;/p&gt;
&lt;p&gt;在Android Studio打开项目的Project Structure，找到具体Module的Dependencies选项卡&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-25/2875300.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到Library项目有个Scope属性，这里的Compile模式就是会把Library的类打包进来，而Provided模式就不会。&lt;/p&gt;
&lt;p&gt;注意，使用Provided模式的Library只能是jar文件，而不能是一个Android Library模块（如appcompat-v7），因为Provided模式只需要依赖Library的API，Android Library模块可能自带了一些res资源，这些资源无法一并塞进标准的jar文件里面。到这里我们明白，Android SDK的代码其实是打包进系统ROM（俗称Framework层级）里面的，我们开发Android项目的时候，只是以Provided模式引用android.jar，从这个角度也佐证了上面谈到的“为什么APP实际运行时AssetManager类的逻辑会与Android SDK里的源码不一样”。&lt;/p&gt;
&lt;p&gt;现在好办了，如果要在插件里使用主项目的ImageLoader，我们可以把ImageLoader的相关代码抽离成一个Android Libary项目，主项目以Compile模式引用这个Libary，而插件项目以Provided模式引用这个Library（编译出来的jar），这样能实现两者之间的交互了，当然代价也是明显的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们应该只给插件开放一些必要的接口，不然会有安全性问题；&lt;/li&gt;
&lt;li&gt;作为通用模块的Library应该保持不变（起码接口不变），不然主项目与插件项目的版本同步会复杂许多；&lt;/li&gt;
&lt;li&gt;因为插件项目已经严重依赖主项目了，所以插件项目不能独立运行，因为缺少必要的 &lt;strong&gt;环境&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后我们再说说“热部署”和“插件化”的区别，一般我们把独立运行的插件APK叫热部署，而需要依赖主项目的环境运行的插件APK叫做插件化。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;简单模式中，使用ClassLoader加载外部的Dex或Apk文件，可以加载一些本地APP不存在的类（或者更新本地已存在的类），从而执行一些新的代码逻辑，但是使用这种方法却不能直接启动插件里的Activity等组件，也没办法使用res资源，如果不解决这两个问题，则使用插件化的方式开发Android业务会非常繁琐。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="代理Activity" scheme="http://kaedea.com/tags/%E4%BB%A3%E7%90%86Activity/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>魔都漫展 COMICCUP18 DAY1</title>
    <link href="http://kaedea.com/2016/06/09/living-cp18-video/"/>
    <id>http://kaedea.com/2016/06/09/living-cp18-video/</id>
    <published>2016-06-08T16:00:00.000Z</published>
    <updated>2016-06-26T08:36:32.000Z</updated>
    
    <content type="html">&lt;!-- css --&gt;
&lt;style type=&quot;text/css&quot;&gt;
embed {
   display: block;
   margin:  10px auto 0px auto;
}
&lt;/style&gt;

&lt;embed height=&quot;452&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;http://share.acg.tv/flash.swf&quot; flashvars=&quot;aid=4982268&amp;page=1&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;

&lt;p&gt;转眼间来B站工作已经有2个月了，这是第一天粗来玩，9号一个人逛CP18，找基友章鱼的摊位，被安利了一张CD，现场许多萌妹子，发了不少牢骚（求个妹纸一起吃自助餐、看电影、逛漫展）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;!-- css --&gt;
&lt;style type=&quot;text/css&quot;&gt;
embed {
   display: block;
   margin:  10px auto 0px auto;
}
&lt;/style&gt;

&lt;embed height=&quot;452&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;http://share.acg.tv/flash.swf&quot; flashvars=&quot;aid=4982268&amp;page=1&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;&lt;/embed&gt;

&lt;p&gt;转眼间来B站工作已经有2个月了，这是第一天粗来玩，9号一个人逛CP18，找基友章鱼的摊位，被安利了一张CD，现场许多萌妹子，发了不少牢骚（求个妹纸一起吃自助餐、看电影、逛漫展）。&lt;br&gt;
    
    </summary>
    
      <category term="Living" scheme="http://kaedea.com/categories/Living/"/>
    
    
      <category term="CP18" scheme="http://kaedea.com/tags/CP18/"/>
    
      <category term="漫展" scheme="http://kaedea.com/tags/%E6%BC%AB%E5%B1%95/"/>
    
      <category term="视频" scheme="http://kaedea.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>简单的动态加载模式</title>
    <link href="http://kaedea.com/2016/06/05/android-dynamical-loading-05-so-simple-mode/"/>
    <id>http://kaedea.com/2016/06/05/android-dynamical-loading-05-so-simple-mode/</id>
    <published>2016-06-04T16:00:00.000Z</published>
    <updated>2016-06-19T06:17:15.000Z</updated>
    
    <content type="html">&lt;p&gt;从这个章节开始，加载SO库的问题算是告一段落，现在开始谈及的动态加载，主要是指基于ClassLoader的加载方式，这也是这个动态加载系列文章的核心。&lt;/p&gt;
&lt;p&gt;Java程序中，JVM虚拟机是通过类加载器ClassLoader加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件，而是加载 &lt;strong&gt;.dex&lt;/strong&gt; 文件。通过Android SDK提供的 &lt;strong&gt;DX工具&lt;/strong&gt; 把 &lt;strong&gt;.jar&lt;/strong&gt; 文件优化成 &lt;strong&gt;.dex&lt;/strong&gt; 文件，然后Android的虚拟机才能加载。注意，有的Android应用能直接加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件，那是因为这个 &lt;strong&gt;.jar&lt;/strong&gt; 文件已经经过优化，只不过后缀名没改（其实已经是 &lt;strong&gt;.dex&lt;/strong&gt; 文件）。&lt;/p&gt;
&lt;p&gt;如果对ClassLoader的工作机制有兴趣，具体过程请参考 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/20524252&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态加载基础 ClassLoader的工作机制&lt;/a&gt;，这里不再赘述。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何获取能够加载的DEX文件&quot;&gt;&lt;a href=&quot;#如何获取能够加载的DEX文件&quot; class=&quot;headerlink&quot; title=&quot;如何获取能够加载的DEX文件&quot;&gt;&lt;/a&gt;如何获取能够加载的DEX文件&lt;/h2&gt;&lt;p&gt;首先我们可以通过JDK的编译命令javac把Java代码编译成 &lt;strong&gt;.class&lt;/strong&gt; 文件，再使用jar命令把 &lt;strong&gt;.class&lt;/strong&gt; 文件封装成 &lt;strong&gt;.jar&lt;/strong&gt; 文件，这与编译普通Java程序的时候完全一样。&lt;/p&gt;
&lt;p&gt;之后再用Android SDK的DX工具把 &lt;strong&gt;.jar&lt;/strong&gt; 文件优化成 &lt;strong&gt;.dex&lt;/strong&gt; 文件（在“android-sdk\build-tools\具体版本\”路径下）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dx –dex –output=target.dex origin.jar          // target.dex就是我们要的了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，我们可以先把代码编译成APK文件，再把APK里面的 &lt;strong&gt;.dex&lt;/strong&gt; 文件解压出来，或者直接把APK文件当成 &lt;strong&gt;.dex&lt;/strong&gt; 使用（只是APK里面的静态资源文件我们暂时还用不到）。至此我们发现，无论加载 &lt;strong&gt;.jar&lt;/strong&gt;，还是 &lt;strong&gt;.apk&lt;/strong&gt;，其实都和加载 &lt;strong&gt;.dex&lt;/strong&gt; 是等价的，Android能加载 &lt;strong&gt;.jar&lt;/strong&gt; 和 &lt;strong&gt;.apk&lt;/strong&gt;，是因为它们都包含有 &lt;strong&gt;.dex&lt;/strong&gt;，直接加载 &lt;strong&gt;.apk&lt;/strong&gt; 文件时，ClassLoader也会自动把 &lt;strong&gt;.apk&lt;/strong&gt; 里的 &lt;strong&gt;.dex&lt;/strong&gt; 解压出来（具体实现代码，有兴趣的话请阅读DexClassLoader和DexFile的源码，兴许以后开个源码分析系列的文章再仔细探讨吧）。&lt;/p&gt;
&lt;h2 id=&quot;加载并调用DEX文件里面的方法&quot;&gt;&lt;a href=&quot;#加载并调用DEX文件里面的方法&quot; class=&quot;headerlink&quot; title=&quot;加载并调用DEX文件里面的方法&quot;&gt;&lt;/a&gt;加载并调用DEX文件里面的方法&lt;/h2&gt;&lt;p&gt;与JVM不同，Android的虚拟机不能用ClassCload直接加载 &lt;strong&gt;.dex&lt;/strong&gt;，而是要用DexClassLoader或者PathClassLoader,他们都是ClassLoader的子类，这两者的区别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DexClassLoader：可以加载 &lt;strong&gt;.jar/apk/dex&lt;/strong&gt; 文件，可以从SD卡中加载未安装的APK；&lt;/li&gt;
&lt;li&gt;PathClassLoader：要传入系统中已经安装过的 &lt;strong&gt;.apk&lt;/strong&gt; 文件的存放Path，所以只能加载已经安装的APK；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用前，先看看DexClassLoader的构造方法&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;((String)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (File)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (String)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (ClassLoader)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意，我们之前提到的，DexClassLoader并不能直接加载外部存储等noexec存储路径中的 &lt;strong&gt;.dex&lt;/strong&gt; 文件，而是要先拷贝到内部存储里。这里的dexPath就是 &lt;strong&gt;.dex&lt;/strong&gt; 的外部存储路径，而optimizedDirectory则是内部路径（exec存储），libraryPath是Native库（其实就是SO库）的所在路径，必须是内部路径，如果不需要用到SO库的话这里直接用null即可，parent则是要传入当前应用的ClassLoader，这与ClassLoader的“双亲代理模式”有关。实际上，DexClassLoader之所以能加载SD卡中的APK文件，就是因为它会先提取并优化dexPath路径上APK文件中的 &lt;strong&gt;.dex&lt;/strong&gt; 文件，并保存到optimizedDirectory路径上，然后再加载优化好的 &lt;strong&gt;.dex&lt;/strong&gt; 文件，所有的动态加载只能发生在exec存储路径上。&lt;/p&gt;
&lt;p&gt;注意，如果 &lt;strong&gt;.dex&lt;/strong&gt; 里面有用到SO库相关的代码，我们需要事先把SO库拷贝到内部存储路径，并把路径作为参数传给libraryPath，或者如果你不想在创建DexClassLoader的时候就加载SO库，可以把libraryPath置为null，并确保在调用相关的Native方法前，使用System#loadLibrary加载了相应的SO库。这里我们并不需要用到SO库，所以才使用null。&lt;/p&gt;
&lt;p&gt;实例使用DexClassLoader的代码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;File optimizedDexOutputPath = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &lt;span class=&quot;string&quot;&gt;&quot;test_dexloader.jar&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 外部路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File dexOutputDir = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getDir(&lt;span class=&quot;string&quot;&gt;&quot;dex&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 无法直接从外部路径加载.dex文件，需要指定APP内部路径作为缓存目录（.dex文件会被解压到此目录）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DexClassLoader dexClassLoader = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DexClassLoader(optimizedDexOutputPath.getAbsolutePath(),dexOutputDir.getAbsolutePath(), &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, getClassLoader());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们已经成功把 &lt;strong&gt;.dex&lt;/strong&gt; 文件给加载进来了，接下来就是如何调用 &lt;strong&gt;.dex&lt;/strong&gt; 里面的代码，主要有两种方式。&lt;/p&gt;
&lt;h3 id=&quot;使用反射的方式&quot;&gt;&lt;a href=&quot;#使用反射的方式&quot; class=&quot;headerlink&quot; title=&quot;使用反射的方式&quot;&gt;&lt;/a&gt;使用反射的方式&lt;/h3&gt;&lt;p&gt;使用DexClassLoader加载进来的类，我们本地并没有这些类的源码，所以无法直接调用新加载进来的类，不过可以通过反射的方法调用，简单粗暴。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DexClassLoader dexClassLoader = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DexClassLoader(optimizedDexOutputPath.getAbsolutePath(), dexOutputDir.getAbsolutePath(), &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, getClassLoader());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Class libProviderClazz = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				libProviderClazz = dexClassLoader.loadClass(&lt;span class=&quot;string&quot;&gt;&quot;me.kaede.dexclassloader.MyLoader&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;// 遍历类里所有方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				Method[] methods = libProviderClazz.getDeclaredMethods();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; methods.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					Log.e(TAG, methods[i].toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				Method start = libProviderClazz.getDeclaredMethod(&lt;span class=&quot;string&quot;&gt;&quot;func&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 获取方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				start.setAccessible(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 把方法设为public，让外部可以调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				String string = (String) start.invoke(libProviderClazz.newInstance());&lt;span class=&quot;comment&quot;&gt;// 调用方法并获取返回值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				Toast.makeText(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, string, Toast.LENGTH_LONG).show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception exception) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;comment&quot;&gt;// Handle exception gracefully here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				exception.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用接口的方式&quot;&gt;&lt;a href=&quot;#使用接口的方式&quot; class=&quot;headerlink&quot; title=&quot;使用接口的方式&quot;&gt;&lt;/a&gt;使用接口的方式&lt;/h3&gt;&lt;p&gt;使用反射的方式不利于代码维护，如果动态加载的业务是多变的话，就不适合了。毕竟 &lt;strong&gt;.dex&lt;/strong&gt; 里面的类也是我们自己维护的，所以可以设计一个宿主和插件共用的基础类，把方法抽象成公共接口，再把这些接口复制到公共库里面去，宿主项目和插件项目都依赖公共库，这样就可以通过这些接口调用动态加载插件得到的类的方法了。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pulic &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IFunc&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IFunc ifunc = (IFunc)libProviderClazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String string = ifunc.func(); &lt;span class=&quot;comment&quot;&gt;// 这样看上去是不是比较好维护&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Toast.makeText(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, string, Toast.LENGTH_LONG).show();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们已经成功从外部路径动态加载一个 &lt;strong&gt;.dex&lt;/strong&gt; 文件，并执行里面的代码逻辑了。通过从服务器下载最新的 &lt;strong&gt;.dex&lt;/strong&gt; 文件并替换本地的旧文件，就能初步实现“APP的动态升级了”。但是这只是非常基础的功能，所以我称之为“简单加载”。从一般的Android开发需要来看，“简单动态加载”虽然能动态更换类了，但还是有不少问题需要解决。&lt;/p&gt;
&lt;h2 id=&quot;如何动态更改XML布局&quot;&gt;&lt;a href=&quot;#如何动态更改XML布局&quot; class=&quot;headerlink&quot; title=&quot;如何动态更改XML布局&quot;&gt;&lt;/a&gt;如何动态更改XML布局&lt;/h2&gt;&lt;p&gt;虽然已经能动态更改代码逻辑了，但是UI界面要怎么更改啊？Android开发中大部分的情况下，UI界面都是通过XML布局实现的，放在res目录下，可是 &lt;strong&gt;.dex&lt;/strong&gt; 库里面并没有这些静态资源啊，所以无法改变XML布局。（这里即使直接动态加载APK文件，但是通过DexClassLoader只能加载新的APK其中的 &lt;strong&gt;.dex&lt;/strong&gt; 文件，并无法加载其中的res资源文件，所以如果在动态加载的 &lt;strong&gt;.dex&lt;/strong&gt; 的类中直接使用新的APK的res资源的话会抛出异常。）&lt;/p&gt;
&lt;p&gt;大家都知道，所有的XML布局在运行的时候都要通过LayoutInflator渲染成View的实例，这个实例与我们使用纯Java代码创建的View实例几乎是等价的，而且后者可能效率还更高，所有的XML布局实现的UI界面都有等价的纯代码的创建方案。由此伸展开来，&lt;strong&gt;res目录下所有XML资源都有等价的纯代码的实现方式&lt;/strong&gt;，比如XML动画、XML Drawable等。&lt;/p&gt;
&lt;p&gt;所以，如果想要动态更改应用的UI界面的话，可以通过用纯代码创建布局的形式来解决。此外，还可以模仿LayoutInflator的工作方式，自己写一套布局渲染机制来代替系统的LayoutInflator方案（类似于许多跨平台游戏引擎的方案），这样就能在完全不依赖res资源的情况下创建UI界面了，当然这样的工作量不少，而且，完全避开res资源的话，所有的分辨率、国际化等自适应问题都要自己在应用层写代码维护了，显然脱离res资源框架不是一个很明智的做法，&lt;strong&gt;但是这种做法确实可行&lt;/strong&gt;，在我们之前的实际生产中的项目中也稳定使用着，这里出于责任问题就不方便公开细节了。&lt;/p&gt;
&lt;p&gt;（早期还没有解决res资源的方案，现在有了，宝宝心里苦 🌚，说实在，这种方案非常繁琐，不好维护，一方面，这是产品一句“技术可行就做呗”而产生的解决方案；另一方面，当时动态加载技术还很不成熟，也没有什么实际投入到生产的项目，所以采取了非常保守的开发方式）。&lt;/p&gt;
&lt;h2 id=&quot;使用Fragment代替Activity&quot;&gt;&lt;a href=&quot;#使用Fragment代替Activity&quot; class=&quot;headerlink&quot; title=&quot;使用Fragment代替Activity&quot;&gt;&lt;/a&gt;使用Fragment代替Activity&lt;/h2&gt;&lt;p&gt;Activity需要在Manifest里注册，然后以标准的Intent启动才会具有生命周期（详情参考AMS的工作机制），很明显，如果想要动态加载的 &lt;strong&gt;.dex&lt;/strong&gt; 里的Activity没有注册的话，是无法启动的。&lt;/p&gt;
&lt;p&gt;有一种简单粗暴的做法就是可以把 &lt;strong&gt;.dex&lt;/strong&gt; 里所有需要用到的Activity都事先注册到原项目里，不过这样只适用于Activity数量不经常改变的业务，如果 &lt;strong&gt;.dex&lt;/strong&gt; 里的Activity有变化，原项目就必须跟着升级。另外一种方案是使用Fragment，Fragment只是普通的Java类，不是组件类，但是自带生命周期（同步FragmentActivity的），不需要在Manifest里注册，所以可以在 &lt;strong&gt;.dex&lt;/strong&gt; 里使用Fragment来代替Activity，代价就是Fragment之间的切换会繁琐许多。&lt;/p&gt;
&lt;h2 id=&quot;ART模式的兼容性问题&quot;&gt;&lt;a href=&quot;#ART模式的兼容性问题&quot; class=&quot;headerlink&quot; title=&quot;ART模式的兼容性问题&quot;&gt;&lt;/a&gt;ART模式的兼容性问题&lt;/h2&gt;&lt;p&gt;当初我们开始设计动态加载方案的时候，还没有ART模式。随着Kitkat的发布以及ART模式的出现，我们开始担心“用DexClassLoader加载 &lt;strong&gt;.dex&lt;/strong&gt; 文件”的方案会不会在ART模式上面存在兼容性问题。&lt;/p&gt;
&lt;p&gt;其实，ART模式相比原来的Dalvik，会在安装APK的时候，使用Android系统自带的 &lt;strong&gt;dex2oat&lt;/strong&gt; 工具把APK里面的. &lt;strong&gt;.dex&lt;/strong&gt; 文件转化成 &lt;strong&gt;OAT&lt;/strong&gt; 文件， &lt;strong&gt;OAT&lt;/strong&gt; 文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。ART模式的系统里，同样存在DexClassLoader类，包名路径也没变，只不过它的具体实现与原来的有所不同，但是接口是一致的。（如果你熟悉设计模式的话，应该会知道有种原则叫做“针对接口编程，而不针对实现编程”，就是因为接口没有变化，才能保证ART模式的向下兼容。）&lt;/p&gt;
&lt;p&gt;在Kitkat项目的源码中，我们依然能找到同样API的DexClassLoader：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; dalvik.system;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; dalvik.system.BaseDexClassLoader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.io.File;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;((String)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (File)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (String)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, (ClassLoader)&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也就是说，ART模式在加载 &lt;strong&gt;.dex&lt;/strong&gt; 文件的方法上，对Dalvik做了向下兼容，所以使用DexClassLoader加载进来的 &lt;strong&gt;.dex&lt;/strong&gt; 文件同样也会被转化成OAT文件再被执行，“以DexClassLoader为核心的动态加载方案”在ART模式上可以稳定运行。&lt;/p&gt;
&lt;p&gt;关于ART模式以及OAT文件的详细分析，请参考官方的&lt;a href=&quot;https://source.android.com/devices/tech/dalvik/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ART and Dalvik&lt;/a&gt;，以及老罗的&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/18006645&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android ART运行时无缝替换Dalvik虚拟机的过程分析&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;存在的问题与改进方案&quot;&gt;&lt;a href=&quot;#存在的问题与改进方案&quot; class=&quot;headerlink&quot; title=&quot;存在的问题与改进方案&quot;&gt;&lt;/a&gt;存在的问题与改进方案&lt;/h2&gt;&lt;p&gt;以上大致就是“Android动态性加载初级阶段”的解决方案，虽然现在已经能投入到具体的生产中去，但是还有一些问题无法忽略。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法使用res目录下的资源，比如layout、values等；&lt;/li&gt;
&lt;li&gt;无法动态加载新的Activity等组件，因为这些组件需要在Manifest中注册，动态加载无法更改当前APK的Manifest；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这些问题没有解决的情况下，虽然可以以比较“绕”的方式开发插件项目，但是还是过于繁琐（方正我是受不了）。以上问题可以通过 &lt;strong&gt;使用反射调用Framework层的隐藏API接口加载res资源&lt;/strong&gt; 以及 &lt;strong&gt;代理Activity&lt;/strong&gt; 的方式解决，可以把这种的动态加载框架成为“代理模式”。在代理模式下，我们能以接近常规Android开发的方式开发插件项目。&lt;/p&gt;
&lt;h2 id=&quot;参考日志&quot;&gt;&lt;a href=&quot;#参考日志&quot; class=&quot;headerlink&quot; title=&quot;参考日志&quot;&gt;&lt;/a&gt;参考日志&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://44289533.iteye.com/blog/1954453&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://44289533.iteye.com/blog/1954453&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/bboyfeiyu/article/details/11710497&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/bboyfeiyu/article/details/11710497&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/over140/archive/2011/11/23/2259367.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/over140/archive/2011/11/23/2259367.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从这个章节开始，加载SO库的问题算是告一段落，现在开始谈及的动态加载，主要是指基于ClassLoader的加载方式，这也是这个动态加载系列文章的核心。&lt;/p&gt;
&lt;p&gt;Java程序中，JVM虚拟机是通过类加载器ClassLoader加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件里面的类的。Android也类似，不过Android用的是Dalvik/ART虚拟机，不是JVM，也不能直接加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件，而是加载 &lt;strong&gt;.dex&lt;/strong&gt; 文件。通过Android SDK提供的 &lt;strong&gt;DX工具&lt;/strong&gt; 把 &lt;strong&gt;.jar&lt;/strong&gt; 文件优化成 &lt;strong&gt;.dex&lt;/strong&gt; 文件，然后Android的虚拟机才能加载。注意，有的Android应用能直接加载 &lt;strong&gt;.jar&lt;/strong&gt; 文件，那是因为这个 &lt;strong&gt;.jar&lt;/strong&gt; 文件已经经过优化，只不过后缀名没改（其实已经是 &lt;strong&gt;.dex&lt;/strong&gt; 文件）。&lt;/p&gt;
&lt;p&gt;如果对ClassLoader的工作机制有兴趣，具体过程请参考 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/20524252&quot;&gt;动态加载基础 ClassLoader的工作机制&lt;/a&gt;，这里不再赘述。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用SO库时要注意的一些问题</title>
    <link href="http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/"/>
    <id>http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/</id>
    <published>2016-06-03T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;正好动态加载系列文章谈到了加载SO库的地方，我觉得这里可以顺便谈谈使用SO库时需要注意的一些问题。或许这些问题对于经常和SO库开发打交道的同学来说已经是老生长谈，但是既然要讨论一整个动态加载系列，我想还是有必要说说使用SO库时的一些问题。&lt;/p&gt;
&lt;p&gt;在项目里使用SO库非常简单，在 &lt;a href=&quot;#&quot;&gt;加载SD卡中的SO库&lt;/a&gt; 中也有谈到，只需要把需要用到的SO库拷贝进 &lt;strong&gt;jniLibs(或者Eclipse项目里面的libs)&lt;/strong&gt; 中，然后在JAVA代码中调用 &lt;strong&gt;System.loadLibrary(“xxx”)&lt;/strong&gt; 加载对应的SO库，就可以使用JNI语句调用SO库里面的Native方法了。&lt;/p&gt;
&lt;p&gt;但是有同学注意到了，SO库文件可以随便改文件名，却不能任意修改文件夹路径，而是“armeabi”、“armeabi-v7a”、“x86”等文件夹名有着严格的要求，这些文件夹名有什么意义么？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;SO库类型和CPU架构类型&quot;&gt;&lt;a href=&quot;#SO库类型和CPU架构类型&quot; class=&quot;headerlink&quot; title=&quot;SO库类型和CPU架构类型&quot;&gt;&lt;/a&gt;SO库类型和CPU架构类型&lt;/h2&gt;&lt;p&gt;原因很简单，不同CPU架构的设备需要用不同类型SO库（从文件名也可以猜出来个大概嘛 ╮(￣▽￣”)╭）。&lt;/p&gt;
&lt;p&gt;记得还在学校的时候，提及ARM处理器时，老师说以后移动设备的CPU基本就是ARM类型的了。老师不曾欺我，早期的Android系统几乎只支持ARM的CPU架构，不过现在至少支持以下七种不同的CPU架构：ARMv5，ARMv7，x86，MIPS，ARMv8，MIPS64和x86_64。每一种CPU类型都对应一种ABI（Application Binary Interface），“armeabi-v7a”文件夹前面的“armeabi”指的就是ARM这种类型的ABI，后面的“v7a”指的是ARMv7。这7种CPU类型对应的SO库的文件夹名是：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。&lt;/p&gt;
&lt;p&gt;不同类型的移动设备在运行APP时，需要加载自己支持的类型的SO库，不然就GG了。通过 &lt;strong&gt;Build.SUPPORTED_ABIS&lt;/strong&gt; 我们可以判断当前设备支持的ABI，不过一般情况下，不需要开发者自己去判断ABI，Android系统在安装APK的时候，不会安装APK里面全部的SO库文件，而是会根据当前CPU类型支持的ABI，从APK里面拷贝最合适的SO库，并保存在APP的内部存储路径的 &lt;strong&gt;libs&lt;/strong&gt; 下面。（这里说一般情况，是因为有例外的情况存在，比如我们动态加载外部的SO库的时候，就需要自己判断ABI类型了。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一种CPU架构　=　一种对应的ABI参数　=　 一种对应类型的SO库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，我们发现使用SO库的逻辑还是比较简单的，但是Android系统加载SO库的逻辑还是给我们留下了一些坑。&lt;/p&gt;
&lt;h2 id=&quot;使用SO库时要注意的一些问题&quot;&gt;&lt;a href=&quot;#使用SO库时要注意的一些问题&quot; class=&quot;headerlink&quot; title=&quot;使用SO库时要注意的一些问题&quot;&gt;&lt;/a&gt;使用SO库时要注意的一些问题&lt;/h2&gt;&lt;h3 id=&quot;1-别把SO库放错地方&quot;&gt;&lt;a href=&quot;#1-别把SO库放错地方&quot; class=&quot;headerlink&quot; title=&quot;1. 别把SO库放错地方&quot;&gt;&lt;/a&gt;1. 别把SO库放错地方&lt;/h3&gt;&lt;p&gt;SO库其实都是APP运行时加载的，也就是说APP只有在运行的时候才知道SO库文件的存在，这就无法通过静态代码检查或者在编译APP时检查SO库文件是否正常。所以，Android开发对SO库的存放路径有严格的要求。&lt;/p&gt;
&lt;p&gt;使用SO库的时候，除了“armeabi-v7a”等文件夹名需要严格按照规定的来自外，SO库要放在项目的哪个文件夹下也要按照套路来，以下是一些总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android Studio 工程放在 &lt;strong&gt;jniLibs/xxxabi&lt;/strong&gt; 目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）；&lt;/li&gt;
&lt;li&gt;Eclipse 工程放在 &lt;strong&gt;libs/xxxabi&lt;/strong&gt; 目录中（这也是使用ndk-build命令生成SO库的默认目录）；&lt;/li&gt;
&lt;li&gt;aar 依赖包中位于 &lt;strong&gt;jni/ABI&lt;/strong&gt; 目录中（SO库会自动包含到引用AAR压缩包到APK中）；&lt;/li&gt;
&lt;li&gt;最终构建出来的APK文件中，SO库存在 &lt;strong&gt;lib/xxxabi&lt;/strong&gt; 目录中（也就是说无论你用什么方式构建，只要保证APK包里SO库的这个路径没错就没问题）；&lt;/li&gt;
&lt;li&gt;通过 PackageManager 安装后，在小于 Android 5.0 的系统中，SO库位于 APP 的 &lt;strong&gt;nativeLibraryPath&lt;/strong&gt; 目录中；在大于等于 Android 5.0 的系统中，SO库位于 APP 的 &lt;strong&gt;nativeLibraryRootDir/CPU_ARCH&lt;/strong&gt; 目录中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然扯到了这里，顺便说一下，我在使用 Android Studio 1.5 构建APK的时候，发现 Gradle 插件只会默认打包application类型的module的jniLibs下面的SO库文件，而不会打包aar依赖包的SO库，所以会导致最终构建出来的APK里的SO库文件缺失。暂时的解决方案是把所有的SO库都放在application模块中（这显然不是很好的解决方案），不知道这是不是Studio的BUG，同事的解决方案是通过修改Gradle插件来增加对aar依赖包的SO库的打包支持（GitHub有开源的第三方Gradle插件项目，使用Java和Groovy语言开发）。&lt;/p&gt;
&lt;h3 id=&quot;2-尽可能提供CPU支持的最优SO库&quot;&gt;&lt;a href=&quot;#2-尽可能提供CPU支持的最优SO库&quot; class=&quot;headerlink&quot; title=&quot;2. 尽可能提供CPU支持的最优SO库&quot;&gt;&lt;/a&gt;2. 尽可能提供CPU支持的最优SO库&lt;/h3&gt;&lt;p&gt;当一个应用安装在设备上，只有该设备支持的CPU架构对应的SO库会被安装。但是，有时候，设备支持的SO库类型不止一种，比如大多的X86设备除了支持X86类型的SO库，还兼容ARM类型的SO库（目前应用市场上大部分的APP只适配了ARM类型的SO库，X86类型的设备如果不能兼容ARM类型的SO库的话，大概要嗝屁了吧）。&lt;/p&gt;
&lt;p&gt;所以如果你的APK只适配了ARM类型的SO库的话，还是能以兼容的模式在X86类型的设备上运行（比如华硕的平板），但是这不意味着你就不用适配X86类型的SO库了，因为X86的CPU使用兼容模式运行ARM类型的SO库会异常卡顿（试着回想几年前你开始学习Android开发的时候，在PC上使用AVD模拟器的那种感觉）。&lt;/p&gt;
&lt;h3 id=&quot;3-注意SO库的编译版本&quot;&gt;&lt;a href=&quot;#3-注意SO库的编译版本&quot; class=&quot;headerlink&quot; title=&quot;3. 注意SO库的编译版本&quot;&gt;&lt;/a&gt;3. 注意SO库的编译版本&lt;/h3&gt;&lt;p&gt;除了要注意使用了正确CPU类型的SO库，也要注意SO库的编译版本的问题。虽然现在的Android Studio支持在项目中直接编译SO库，但是更多的时候我们还是选择使用事先编译好的SO库，这时就要注意了，编译APK的时候，我们总是希望使用最新版本的build-tools来编译，因为Android SDK最新版本会帮我们做出最优的向下兼容工作。&lt;/p&gt;
&lt;p&gt;但是这对于编译SO库来说就不一样了，因为NDK平台不是向下兼容的，而是向上兼容的。应该使用app的minSdkVersion对应的版本的NDK标本来编译SO库文件，如果使用了太高版本的NDK，可能会导致APP性能低下，或者引发一些SO库相关的运行时异常，比如“UnsatisfiedLinkError”，“dlopen: failed”以及其他类型的Crash。&lt;/p&gt;
&lt;p&gt;一般情况下，我们都是使用编译好的SO库文件，所以当你引入一个预编译好的SO库时，你需要检查它被编译所用的平台版本。&lt;/p&gt;
&lt;h3 id=&quot;4-尽可能为每种CPU类型都提供对应的SO库&quot;&gt;&lt;a href=&quot;#4-尽可能为每种CPU类型都提供对应的SO库&quot; class=&quot;headerlink&quot; title=&quot;4. 尽可能为每种CPU类型都提供对应的SO库&quot;&gt;&lt;/a&gt;4. 尽可能为每种CPU类型都提供对应的SO库&lt;/h3&gt;&lt;p&gt;比如有时候，因为业务的需求，我们的APP不需要支持AMR64的设备，但这不意味着我们就不用编译ARM64对应的SO库。举个例子，我们的APP只支持armeabi-v7a和x86架构，然后我们的APP使用了一个第三方的Library，而这个Library提供了AMR64等更多类型CPU架构的支持，构建APK的时候，这些ARM64的SO库依然会被打包进APK里面，也就是说我们自己的SO库没有对应的ARM64的SO库，而第三方的Library却有。这时候，某些ARM64的设备安装该APK的时候，发现我们的APK里带有ARM64的SO库，会误以为我们的APP已经做好了AMR64的适配工作，所以只会选择安装APK里面ARM64类型的SO库，这样会导致我们自己项目的SO库没有被正确安装（虽然armeabi-v7a和x86类型的SO库确实存在APK包里面）。&lt;/p&gt;
&lt;p&gt;这时正确的做法是，给我们自己的SO库也提供AMR64支持，或者不打包第三方Library项目的ARM64的SO库。使用第二种方案时，可以把APK里面不需要支持的ABI文件夹给删除，然后重新打包，而在Android Studio下，则可以通过以下的构建方式指定需要类型的SO库。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;productFlavors &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flavor1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ndk &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;armeabi-v7a&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;x86&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;armeabi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flavor2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ndk &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;armeabi-v7a&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;x86&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;armeabi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;arm64-v8a&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            abiFilters &lt;span class=&quot;string&quot;&gt;&quot;x86_64&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要说明的是，如果我们的项目是SDK项目，我们最好提供全平台类型的SO库支持，因为APP能支持的设备CPU类型的数量，就是项目中所有SO库支持的最少CPU类型的数量（使用我们SDK的APP能支持的CPU类型只能少于等于我们SDK支持的类型）。&lt;/p&gt;
&lt;h3 id=&quot;5-不要通过“减少其他CPU类型支持的SO库”来减少APK的体积&quot;&gt;&lt;a href=&quot;#5-不要通过“减少其他CPU类型支持的SO库”来减少APK的体积&quot; class=&quot;headerlink&quot; title=&quot;5. 不要通过“减少其他CPU类型支持的SO库”来减少APK的体积&quot;&gt;&lt;/a&gt;5. 不要通过“减少其他CPU类型支持的SO库”来减少APK的体积&lt;/h3&gt;&lt;p&gt;确实，所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的SO库，因此似乎移除其他ABIs的SO库是一个减少APK大小的好办法。但事实上并不是，这不只影响到函数库的性能和兼容性。&lt;/p&gt;
&lt;p&gt;X86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备，兼容只是一种保底方案。64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。&lt;/p&gt;
&lt;p&gt;过减少其他CPU类型支持的SO库来减少APK的体积不是很明智的做法，如果真的需要通过减少SO库来做APK瘦身，我们也有其他办法。&lt;/p&gt;
&lt;h2 id=&quot;减少SO库体积的正确姿势&quot;&gt;&lt;a href=&quot;#减少SO库体积的正确姿势&quot; class=&quot;headerlink&quot; title=&quot;减少SO库体积的正确姿势&quot;&gt;&lt;/a&gt;减少SO库体积的正确姿势&lt;/h2&gt;&lt;h3 id=&quot;1-构建特定ABI支持的APK&quot;&gt;&lt;a href=&quot;#1-构建特定ABI支持的APK&quot; class=&quot;headerlink&quot; title=&quot;1. 构建特定ABI支持的APK&quot;&gt;&lt;/a&gt;1. 构建特定ABI支持的APK&lt;/h3&gt;&lt;p&gt;我们可以构建一个APK，它支持所有的CPU类型。但是反过来，我们可以为每个CPU类型都单独构建一个APK，然后不同CPU类型的设备安装对应的APK即可，当然前提是应用市场得提供用户设备CPU类型设别的支持，就目前来说，至少PLAY市场是支持的。&lt;/p&gt;
&lt;p&gt;Gradle可以通过以下配置生成不同ABI支持的APK（引用自别的文章，没实际使用过）：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    splits &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        abi &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            enable &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            reset()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            include &lt;span class=&quot;string&quot;&gt;&#39;x86&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x86_64&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;armeabi-v7a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;arm64-v8a&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//select ABIs to build APKs for&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            universalApk &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//generate an additional APK that contains all the ABIs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// map for the version code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    project.ext.versionCodes = [&lt;span class=&quot;string&quot;&gt;&#39;armeabi&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;armeabi-v7a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;arm64-v8a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;mips&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;mips64&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x86&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;x86_64&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android.applicationVariants.all &amp;#123; variant -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// assign different version code for each output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        variant.outputs.each &amp;#123; output -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            output.versionCodeOverride =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) * &lt;span class=&quot;number&quot;&gt;1000000&lt;/span&gt; + android.defaultConfig.versionCode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-从网络下载当前设备支持的SO库&quot;&gt;&lt;a href=&quot;#2-从网络下载当前设备支持的SO库&quot; class=&quot;headerlink&quot; title=&quot;2. 从网络下载当前设备支持的SO库&quot;&gt;&lt;/a&gt;2. 从网络下载当前设备支持的SO库&lt;/h3&gt;&lt;p&gt;说到这里，总算回到动态加载的主题了。⊙﹏⊙&lt;/p&gt;
&lt;p&gt;使用Android的动态加载技术，可以加载外部的SO库，所以我们可以从网络下载SO库文件并加载了。我们可以下载所有类型的SO库文件，然后加载对应类型的SO库，也可以下载对应类型的SO库然后加载，不过无论哪种方式，我们最好都在加载SO库前，对SO库文件的类型做一下判断。&lt;/p&gt;
&lt;p&gt;我个人的方案是，存储在服务器的SO库依然按照APK包的压缩方式打包，也就是，SO库存放在APK包的 &lt;strong&gt;libs/xxxabi&lt;/strong&gt; 路径下面，下载完带有SO库的APK包后，我们可以遍历libs路径下的所有SO库，选择加载对应类型的SO库。&lt;/p&gt;
&lt;p&gt;具体实现代码看上去像是：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 将一个SO库复制到指定路径，会先检查改SO库是否与当前CPU兼容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; sourceDir     SO库所在目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; so            SO库名字&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; destDir       目标根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; nativeLibName 目标SO库目录名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copySoLib&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File sourceDir, String so, String destDir, String nativeLibName)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isSuccess = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LogUtil.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] 开始处理so文件&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Build.VERSION.SDK_INT &amp;gt;= &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String[] abis = Build.SUPPORTED_ABIS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (abis != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String abi : abis) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    LogUtil.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] try supported abi:&quot;&lt;/span&gt; + abi);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    String name = &lt;span class=&quot;string&quot;&gt;&quot;lib&quot;&lt;/span&gt; + File.separator + abi + File.separator + so;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    File sourceFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(sourceDir, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceFile.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        LogUtil.i(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] copy so: &quot;&lt;/span&gt; + sourceFile.getAbsolutePath());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        isSuccess = FileUtil.copyFile(sourceFile.getAbsolutePath(), destDir + File.separator + nativeLibName + File.separator + so);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;//api21 64位系统的目录可能有些不同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;//copyFile(sourceFile.getAbsolutePath(), destDir + File.separator +  name);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                LogUtil.e(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] get abis == null&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LogUtil.d(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] supported api:&quot;&lt;/span&gt; + Build.CPU_ABI + &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt; + Build.CPU_ABI2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String name = &lt;span class=&quot;string&quot;&gt;&quot;lib&quot;&lt;/span&gt; + File.separator + Build.CPU_ABI + File.separator + so;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            File sourceFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(sourceDir, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!sourceFile.exists() &amp;amp;&amp;amp; Build.CPU_ABI2 != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                name = &lt;span class=&quot;string&quot;&gt;&quot;lib&quot;&lt;/span&gt; + File.separator + Build.CPU_ABI2 + File.separator + so;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                sourceFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(sourceDir, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!sourceFile.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    name = &lt;span class=&quot;string&quot;&gt;&quot;lib&quot;&lt;/span&gt; + File.separator + &lt;span class=&quot;string&quot;&gt;&quot;armeabi&quot;&lt;/span&gt; + File.separator + so;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sourceFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(sourceDir, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceFile.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                LogUtil.i(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] copy so: &quot;&lt;/span&gt; + sourceFile.getAbsolutePath());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                isSuccess = FileUtil.copyFile(sourceFile.getAbsolutePath(), destDir + File.separator + nativeLibName + File.separator + so);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isSuccess) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LogUtil.e(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[copySo] 安装 &quot;&lt;/span&gt; + so + &lt;span class=&quot;string&quot;&gt;&quot; 失败 : NO_MATCHING_ABIS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;string&quot;&gt;&quot;install &quot;&lt;/span&gt; + so + &lt;span class=&quot;string&quot;&gt;&quot; fail : NO_MATCHING_ABIS&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一种CPU架构 = 一种ABI = 一种对应的SO库；&lt;/li&gt;
&lt;li&gt;加载SO库时，需要加载对应类型的SO库；&lt;/li&gt;
&lt;li&gt;尽量提供全平台CPU类型的SO库支持；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;题外话，SO库的使用本身就是一种最纯粹的动态加载技术，SO库本身不参与APK的编译过程，使用JNI调用SO库里的Native方法的方式看上去也像是一种“硬编程”，Native方法看上去与一般的Java静态方法没什么区别，但是它的具体实现却是可以随时动态更换的（更换SO库就好），这也可以用来实现热修复的方案，与Java方法一旦加载进内存就无法再次更换不同，Native方法不需要重启APP就可以随意更换。&lt;/p&gt;
&lt;p&gt;出于安全和生态控制的原因，Google Play市场不允许APP有加载外部可执行文件的行为，一旦你的APK里被检查出有额外的可执行文件时就不好玩了，所以现在许多APP都偷偷把用于动态加载的可执行文件的后缀名换成“.so”，这样被发现的几率就降低了，因为加载SO库看上去就是官方合法版本的动态加载啊（不然SO库怎么工作），虽然这么做看起来有点掩耳盗铃。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/cb05698a1968&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于Android的.so文件你所需要知道的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/limpoxe/Android-Plugin-Framework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android-Plugin-Framework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;正好动态加载系列文章谈到了加载SO库的地方，我觉得这里可以顺便谈谈使用SO库时需要注意的一些问题。或许这些问题对于经常和SO库开发打交道的同学来说已经是老生长谈，但是既然要讨论一整个动态加载系列，我想还是有必要说说使用SO库时的一些问题。&lt;/p&gt;
&lt;p&gt;在项目里使用SO库非常简单，在 &lt;a href=&quot;#&quot;&gt;加载SD卡中的SO库&lt;/a&gt; 中也有谈到，只需要把需要用到的SO库拷贝进 &lt;strong&gt;jniLibs(或者Eclipse项目里面的libs)&lt;/strong&gt; 中，然后在JAVA代码中调用 &lt;strong&gt;System.loadLibrary(“xxx”)&lt;/strong&gt; 加载对应的SO库，就可以使用JNI语句调用SO库里面的Native方法了。&lt;/p&gt;
&lt;p&gt;但是有同学注意到了，SO库文件可以随便改文件名，却不能任意修改文件夹路径，而是“armeabi”、“armeabi-v7a”、“x86”等文件夹名有着严格的要求，这些文件夹名有什么意义么？&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="SO库" scheme="http://kaedea.com/tags/SO%E5%BA%93/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>加载SD卡中的SO库</title>
    <link href="http://kaedea.com/2016/06/01/android-dynamical-loading-03-so-in-sdcard/"/>
    <id>http://kaedea.com/2016/06/01/android-dynamical-loading-03-so-in-sdcard/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;Android中JNI的使用其实就包含了动态加载，APP运行时动态加载&lt;code&gt;.so&lt;/code&gt;库并通过JNI调用其封装好的方法。后者一般是使用NDK工具从C/C++代码编译而成，运行在Native层，效率会比执行在虚拟机的Java代码高很多，所以Android中经常通过动态加载&lt;code&gt;.so&lt;/code&gt;库来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。此外，由于&lt;code&gt;.so&lt;/code&gt;库是由C++编译而来的，只能被反编译成汇编代码，相比Smali更难被破解，因此&lt;code&gt;.so&lt;/code&gt;库也可以被用于安全领域。&lt;/p&gt;
&lt;p&gt;与我们常说的基于ClassLoader的动态加载不同，SO库的加载是使用System类的（由此可见对SO库的支持也是Android的基础功能），所以这里这是作为动态加载系列的补充说明。不过，如果使用ClassLoader加载SD卡里插件APK，而插件APK里面包含有SO库，这就涉及到了对插件APK里的SO库的加载，所以我们也要知道如何加载SD卡里面的SO库。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一般的SO文件的使用姿势&quot;&gt;&lt;a href=&quot;#一般的SO文件的使用姿势&quot; class=&quot;headerlink&quot; title=&quot;一般的SO文件的使用姿势&quot;&gt;&lt;/a&gt;一般的SO文件的使用姿势&lt;/h2&gt;&lt;p&gt;以一个“图片高斯模糊”的功能为例，如果使用Java代码对图像Bitmap的每一个像素点进行计算，那整体耗时将会非常大，所以可以考虑使用JNI。（详细的JNI使用教程网络上有许多，这里不赘述）&lt;/p&gt;
&lt;p&gt;这里推荐一个开源的高斯模糊项目 &lt;a href=&quot;https://github.com/kikoso/android-stackblur&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android StackBlur&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在命令行定位到Android.mk文件所在目录，运行NDK工具的&lt;code&gt;ndk-build&lt;/code&gt;命令就能编译出我们需要SO库&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-26/19622075.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再把SO库复制到Android Studio项目的&lt;code&gt;jniLibs&lt;/code&gt;目录中&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-26/58498917.jpg&quot; alt=&quot;&quot;&gt; &lt;br&gt;&lt;br&gt;（Android Studio现在也支持直接编译SO库，但是有许多坑，这里我选择手动编译）&lt;/p&gt;
&lt;p&gt;接着在Java中把SO库对应的模块加载进来&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// load so file from internal directory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.loadLibrary(&lt;span class=&quot;string&quot;&gt;&quot;stackblur&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			NativeBlurProcess.isLoadLibraryOk.set(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Log.i(&lt;span class=&quot;string&quot;&gt;&quot;MainActivity&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;loadLibrary success!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable throwable) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Log.i(&lt;span class=&quot;string&quot;&gt;&quot;MainActivity&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;loadLibrary error!&quot;&lt;/span&gt; + throwable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;加载成功后就可以直接使用Native方法了&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NativeBlurProcess&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; AtomicBoolean isLoadLibraryOk = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AtomicBoolean(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//native method&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionToBlur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bitmap bitmapOut, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; radius, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threadCount, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; threadIndex, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; round)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由此可见，在Android项目中，SO库的使用也是一种动态加载，在运行时把可执行文件加载进来。一般情况下，SO库都是打包在APK内部的，不允许修改这种“动态加载”看起来不是我们熟悉的那种啊，貌似没什么卵用。不过，其实SO库也是可以存放在外部存储路径的。&lt;/p&gt;
&lt;h2 id=&quot;如何把SO文件存放在外部存储&quot;&gt;&lt;a href=&quot;#如何把SO文件存放在外部存储&quot; class=&quot;headerlink&quot; title=&quot;如何把SO文件存放在外部存储&quot;&gt;&lt;/a&gt;如何把SO文件存放在外部存储&lt;/h2&gt;&lt;p&gt;注意到上面加载SO库的时候我们用到了System类的“loadLibrary”方法，同时我们也发现System类还有一个“load”方法，看起来差不多啊，看看他们有什么区别吧！&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * See &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; Runtime#load&amp;#125;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String pathName)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * See &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; Runtime#loadLibrary&amp;#125;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String libName)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先看看loadLibrary，这里调用了Runtime的loadLibrary，进去一看，又是动态加载熟悉的ClassLoader了（这里也佐证了SO库的使用就是一种动态加载的说法）&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Searches for and loads the given shared library using the given ClassLoader.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loadLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String libraryName, ClassLoader loader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String filename = loader.findLibrary(libraryName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String error = doLoad(filename, loader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看样子就像是通过库名获取一个文件路径，再调用“doLoad”方法加载这个文件，先看看“loader.findLibrary(libraryName)”&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;findLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String libName)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ClassLoader只是一个抽象类，它的大部分工作都在BaseDexClassLoader类中实现，进去看看&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;findLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不对啊，这里只是抛了一个RuntimeException异常，什么都没做啊！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实这里有一个误区&lt;/strong&gt;，也是刚开始开Android SDK源码的同学容易搞混的。Android SDK自带的源码其实只是给我们开发者参考的，基本只是一些常用的类，Google不会把整个Android系统的源码都放到这里来，因为整个项目非常大，ClassLoader类平时我们接触得少，所以它的具体实现的源码并没有打包进SDK里，如果需要，我们要到官方AOSP项目里面去看（顺便一提，整个AOSP5.1项目大小超过150GB，真的有需要的话推荐用一个移动硬盘存储）。&lt;/p&gt;
&lt;p&gt;这里为了方便，我们可以直接看在线的代码 &lt;a href=&quot;https://android.googlesource.com/platform/libcore-snapshot/+/ics-mr1/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BaseDexClassLoader.java&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;findLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; pathList.findLibrary(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再看进去DexPathList类&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Finds the named native code library on any of the library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * directories pointed at by this instance. This will find the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * one in the earliest listed directory, ignoring any that are not&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * readable regular files.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the complete path to the library or &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@code&lt;/span&gt; null&amp;#125; if no&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * library was found&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;findLibrary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String libraryName)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String fileName = System.mapLibraryName(libraryName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (File directory : nativeLibraryDirectories) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(directory, fileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (file.exists() &amp;amp;&amp;amp; file.isFile() &amp;amp;&amp;amp; file.canRead()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; file.getPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里已经明朗了，根据传进来的libName，扫描APK内部的nativeLibrary目录，获取并返回内部SO库文件的完整路径filename。再回到Runtime类，获取filename后调用了“doLoad”方法，看看&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;doLoad&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, ClassLoader loader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String ldLibraryPath = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String dexPath = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loader == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ldLibraryPath = System.getProperty(&lt;span class=&quot;string&quot;&gt;&quot;java.library.path&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (loader &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; BaseDexClassLoader) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ldLibraryPath = dexClassLoader.getLdLibraryPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nativeLoad(name, loader, ldLibraryPath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里就彻底清楚了，调用Native方法“nativeLoad”，通过完整的SO库路径filename，把目标SO库加载进来。&lt;/p&gt;
&lt;p&gt;说了半天还没有进入正题呢，不过我们可以想到，如果使用loadLibrary方法，到最后还是要找到目标SO库的完整路径，再把SO库加载进来，那我们能不能一开始就给出SO库的完整路径，然后直接加载进来？我们猜想load方法就是干这个的，看看。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String absolutePath, ClassLoader loader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (absolutePath == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;string&quot;&gt;&quot;absolutePath == null&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String error = doLoad(absolutePath, loader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我勒个去，一上来就直接来到doLoad方法了，这证明我们的猜想可能是正确的，那么在实际项目中测试看看吧！&lt;/p&gt;
&lt;p&gt;我们先把SO放在Asset里，然后再复制到内部存储，再使用load方法把其加载进来。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AppCompatActivity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		setContentView(R.layout.activity_main);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		File dir = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getDir(&lt;span class=&quot;string&quot;&gt;&quot;jniLibs&quot;&lt;/span&gt;, Activity.MODE_PRIVATE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		File distFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(dir.getAbsolutePath() + File.separator + &lt;span class=&quot;string&quot;&gt;&quot;libstackblur.so&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (copyFileFromAssets(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;libstackblur.so&quot;&lt;/span&gt;, distFile.getAbsolutePath()))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    &lt;span class=&quot;comment&quot;&gt;//使用load方法加载内部储存的SO库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.load(distFile.getAbsolutePath());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			NativeBlurProcess.isLoadLibraryOk.set(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDoBlur&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View view)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ImageView imageView = (ImageView) findViewById(R.id.iv_app);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Bitmap bitmap = BitmapFactory.decodeResource(getResources(), android.R.drawable.sym_def_app_icon);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Bitmap blur = NativeBlurProcess.blur(bitmap,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		imageView.setImageBitmap(blur);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copyFileFromAssets&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, String fileName, String path)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; copyIsFinish = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			InputStream is = context.getAssets().open(fileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			file.createNewFile();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			FileOutputStream fos = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] temp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((i = is.read(temp)) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				fos.write(temp, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			fos.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			is.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			copyIsFinish = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Log.e(&lt;span class=&quot;string&quot;&gt;&quot;MainActivity&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;[copyFileFromAssets] IOException &quot;&lt;/span&gt;+e.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; copyIsFinish;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;点击onDoBlur按钮，果然加载成功了！&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-26/49457004.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;那能不能直接加载外部存储上面的SO库呢，把SO库拷贝到SD卡上面试试。&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-26/91753544.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来是不可以的样子，Permission denied！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.UnsatisfiedLinkError: dlopen failed: couldn’t map “/storage/emulated/0/libstackblur.so” segment 1: Permission denied&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来像是没有权限的样子，看看源码哪里抛出的异常吧&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Loads the given shared library using the given ClassLoader.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String absolutePath, ClassLoader loader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (absolutePath == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;string&quot;&gt;&quot;absolutePath == null&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String error = doLoad(absolutePath, loader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (error != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 这里抛出的异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsatisfiedLinkError(error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;应该是执行doLoad方法时出现了错误，但是上面也看过了，doLoad方法里调用了Native方法“nativeLoad”，那应该就是Native代码里出现的错误。平时我很少看到Native里面，上一次看的时候，是因为需要看看点九图NinePathDrawable的缩放控制信息chunk数组的具体作用是怎么样，费了好久才找到我想要的一小段代码。所以这里就暂时不跟进去了，有兴趣的同学可以告诉我关键代码的位置。&lt;/p&gt;
&lt;p&gt;我在一个Google的开发者论坛上找到了一些答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The SD Card is mounted noexec, so I’m not sure this will work.&lt;br&gt;Moreover, using the SD Card as a storage location is a really bad idea, since any other application can modify/delete/corrupt it easily.&lt;br&gt;Try downloading the library to your application’s data directory instead, and load it from here.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也容易理解，SD卡等外部存储路径是一种可拆卸的（mounted）不可执行（noexec）的储存媒介，不能直接用来作为可执行文件的运行目录，使用前应该把可执行文件复制到APP内部存储再运行。&lt;/p&gt;
&lt;p&gt;最后，我们也可以看看官方的API文档&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-27/73725063.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看来load方法的用途和我们理解的一致，文档里说的shared library就是指SO库（shared object），至此，我们就可以把SO文件移动到外部存储了，或者从网络下载都行。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android中JNI的使用其实就包含了动态加载，APP运行时动态加载&lt;code&gt;.so&lt;/code&gt;库并通过JNI调用其封装好的方法。后者一般是使用NDK工具从C/C++代码编译而成，运行在Native层，效率会比执行在虚拟机的Java代码高很多，所以Android中经常通过动态加载&lt;code&gt;.so&lt;/code&gt;库来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。此外，由于&lt;code&gt;.so&lt;/code&gt;库是由C++编译而来的，只能被反编译成汇编代码，相比Smali更难被破解，因此&lt;code&gt;.so&lt;/code&gt;库也可以被用于安全领域。&lt;/p&gt;
&lt;p&gt;与我们常说的基于ClassLoader的动态加载不同，SO库的加载是使用System类的（由此可见对SO库的支持也是Android的基础功能），所以这里这是作为动态加载系列的补充说明。不过，如果使用ClassLoader加载SD卡里插件APK，而插件APK里面包含有SO库，这就涉及到了对插件APK里的SO库的加载，所以我们也要知道如何加载SD卡里面的SO库。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="SO库" scheme="http://kaedea.com/tags/SO%E5%BA%93/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>海淘FILCO忍者87青轴键盘</title>
    <link href="http://kaedea.com/2016/05/15/tool-get-filco-87/"/>
    <id>http://kaedea.com/2016/05/15/tool-get-filco-87/</id>
    <published>2016-05-14T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/75016346.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机械键盘这种东西就像SSD硬盘一样，一旦用上了就回不去。&lt;/p&gt;
&lt;p&gt;想我这种穷惯了的人，一直以来都是用着买PC送的双飞燕或者大白鲨键鼠套，从来就不会想着花大价钱买一个键盘。第一买键盘大概是我高二的时候，那时候买电脑送的键盘都用烂了，就琢磨着买一个新的，之后周末在我生活的小城市（潮州）的市区逛了一个下午，愣是没有决定买哪一款，最后还挑着最便宜的买了一款。&lt;/p&gt;
&lt;p&gt;上大学的时候，我就想着自己居然选了计算机专业，就得给自己买个好点的键盘，所以那时候买了学校数码店最贵的微软套装，不过马上就后悔了，因为微软的键盘印了大量的中文数字，对我这个喜欢简洁的人来说实在难以接受，而且，比同行贵了一大截的微软键盘居然有按键冲突问题，所以这时候开始我更加决心“键盘能用就行了，没必要买贵的”。&lt;/p&gt;
&lt;p&gt;直到后来开始工作了，我见识到公司研发机的SSD硬盘的好处，所以开始给自己入手SSD。SSD让我意识到了生产工具对于提高工作效率的作用，所以我开始把目光放到键盘上。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;初体验&quot;&gt;&lt;a href=&quot;#初体验&quot; class=&quot;headerlink&quot; title=&quot;初体验&quot;&gt;&lt;/a&gt;初体验&lt;/h4&gt;&lt;p&gt;第一次看上的机械键盘是 &lt;strong&gt;IBKC POKER系列&lt;/strong&gt;，颜值实在高，不过一直犹豫没有方向键能不能满足日常开发的需要，所以迟迟没有下手。有一次，在B站看机械键盘的介绍视频的时候，看见有人推荐雷柏的国产黄轴机械键盘，相比其他一般的500，动辄上千的键盘，这款键盘才不到200大洋，所以解决买一款回来体验一番。&lt;/p&gt;
&lt;p&gt;虽然是国产垃圾轴的便宜货，但是用起来还还真的比一般的薄膜键盘好许多，我开始意识到键盘也是提高工作效率的一大神器，然后开始把目光放到其他中高档的机械键盘，选择标准就是 &lt;strong&gt;颜值 + Cherry轴&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;无法自拔&quot;&gt;&lt;a href=&quot;#无法自拔&quot; class=&quot;headerlink&quot; title=&quot;无法自拔&quot;&gt;&lt;/a&gt;无法自拔&lt;/h4&gt;&lt;p&gt;自从开始用上了机械键盘后，每次使用回薄膜键盘都会觉得一股廉价的感觉，特别是公司那种给员工配套的键鼠套装。因为机械键盘比较厚重（里面有钢板），所以键盘一直放在公司，然后我就开始考虑给宿舍也买一个机械键盘了，不过由于我快要换工作了，所以就没有急着买，后来我离职的时候，考虑到键盘毕竟是最便宜档次的，一起从广州带过来上海不划算，所以就送给了同事（虽然他一脸嫌弃的样子）。&lt;/p&gt;
&lt;p&gt;来到B站后，公司给我配的是逻辑的键鼠套装，果然现在用起来还是很别扭了，所以我就想赶紧入手一款新的机械键盘。一开始看上的是 &lt;strong&gt;IKBC C87&lt;/strong&gt;，和G87一样的配置，只不过键盘换成了不透光的材质，这正好，反正我一直搞不清楚喜欢把键盘加上LED灯的人到底是什么品位，在和玩CF喜欢买黄金AK47的水平有区别吗？&lt;/p&gt;
&lt;p&gt;考虑到白色容易弄脏，而已大家都喜欢选白色的IKBC，所以我选了黑色版本的C87，只不过把淘宝上面所有的店铺都浏览过后，发现黑色版已经断货了。&lt;/p&gt;
&lt;h4 id=&quot;高潮&quot;&gt;&lt;a href=&quot;#高潮&quot; class=&quot;headerlink&quot; title=&quot;高潮&quot;&gt;&lt;/a&gt;高潮&lt;/h4&gt;&lt;p&gt;接下来一段时间，因为不知道入手哪一款键盘好，所以我一直在浏览那些机械键盘的评测或者导购帖子，后来又看见了IKBC新出的Porker3系列，只不过刚出来，只有茶轴有货，而且造型只有原始白色版，最主要的是死贵，所以也就没有剁手了。&lt;/p&gt;
&lt;p&gt;就这样纠结了一段时间，我开始想着，干嘛不一步到位直接上Filco，因为看评测或者使用心得的帖子，都说大F是机械键盘的高端产品，一些性价比不错的牌子都被形容成“半价Filco”（比如魔力鸭），有想到现在工作实在不容易，从来就没给自己买过什么好东西，所以抱着“一半为了提高工作效率，一半为了犒劳自己”的想法，我决定入手Filco，而目标型号就是87键位青轴，考虑到Filco的键帽似乎容易打油，所以就选了侧刻的忍者系列。&lt;/p&gt;
&lt;p&gt;首先，国内旗舰店买的产品有点贵（899软妹币），然后我就想到了上日亚海淘，上去一看价格大概700左右，所以就在日亚下单了。转运的时候是周末，EMS信息上出现了“保管”的字样，我还以为被税了，后来证实是周末EMS不上，周一才送到公司，虚惊一场。&lt;/p&gt;
&lt;p&gt;话说，虽然在日亚买便宜差不多200，但是运费也要100+，所以其实并不划算，如果被税了就更惨了。&lt;/p&gt;
&lt;h4 id=&quot;贤者模式&quot;&gt;&lt;a href=&quot;#贤者模式&quot; class=&quot;headerlink&quot; title=&quot;贤者模式&quot;&gt;&lt;/a&gt;贤者模式&lt;/h4&gt;&lt;p&gt;拿到手的是一刻，那种久违的厚重感又出现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-15/76636885.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-15/48248248.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我还以为会送一些键帽，事实证明是我想多了，盒子里就只有键盘、拔键器、转接口说明书，没有大键位键帽，就只有两个前刻和正刻的WIN键，没什么卵用，对了还有一个塑料盖……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-15/10590460.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本来以为大F会带给我一些惊喜，不过其实用起来感觉并没有比其他国产品牌好多少，果然只要是Cherry轴的话，就没有多大区别么。最郁闷的是，我发现键盘右上角的键好像有点“卡”，这就是传说中的臭轴么？&lt;/p&gt;
&lt;p&gt;没有键盘托的话，用起来手有点不舒服，不过旗舰店卖的键盘托都是好几百，坑。&lt;/p&gt;
&lt;h4 id=&quot;感想&quot;&gt;&lt;a href=&quot;#感想&quot; class=&quot;headerlink&quot; title=&quot;感想&quot;&gt;&lt;/a&gt;感想&lt;/h4&gt;&lt;p&gt;说实在，有点失望。本来打算买一套键帽，不过黑色的话，感觉没什么好搭配的键帽呢，日后再说吧。下一个买茶轴吧，IKBC？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-11/75016346.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;机械键盘这种东西就像SSD硬盘一样，一旦用上了就回不去。&lt;/p&gt;
&lt;p&gt;想我这种穷惯了的人，一直以来都是用着买PC送的双飞燕或者大白鲨键鼠套，从来就不会想着花大价钱买一个键盘。第一买键盘大概是我高二的时候，那时候买电脑送的键盘都用烂了，就琢磨着买一个新的，之后周末在我生活的小城市（潮州）的市区逛了一个下午，愣是没有决定买哪一款，最后还挑着最便宜的买了一款。&lt;/p&gt;
&lt;p&gt;上大学的时候，我就想着自己居然选了计算机专业，就得给自己买个好点的键盘，所以那时候买了学校数码店最贵的微软套装，不过马上就后悔了，因为微软的键盘印了大量的中文数字，对我这个喜欢简洁的人来说实在难以接受，而且，比同行贵了一大截的微软键盘居然有按键冲突问题，所以这时候开始我更加决心“键盘能用就行了，没必要买贵的”。&lt;/p&gt;
&lt;p&gt;直到后来开始工作了，我见识到公司研发机的SSD硬盘的好处，所以开始给自己入手SSD。SSD让我意识到了生产工具对于提高工作效率的作用，所以我开始把目光放到键盘上。&lt;br&gt;
    
    </summary>
    
      <category term="生产工具" scheme="http://kaedea.com/categories/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>动态加载的类型</title>
    <link href="http://kaedea.com/2016/05/14/android-dynamical-loading-02-type/"/>
    <id>http://kaedea.com/2016/05/14/android-dynamical-loading-02-type/</id>
    <published>2016-05-13T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-8/68653221.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在网络上有许多关于动态加载的介绍的文章，谈及的关键词汇有动态加载、插件化、热部署、热修复等，对于一些刚接触这方面开发技术的人来说，可能容易混淆。&lt;/p&gt;
&lt;p&gt;虽然我在动态加载系列的文章中或多或少有谈到这些概念的区别，但是我觉得认识这些区别对于使用动态加载技术还是挺重要的，所以特别开这个新的文章进行分析。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;动态加载的类型&quot;&gt;&lt;a href=&quot;#动态加载的类型&quot; class=&quot;headerlink&quot; title=&quot;动态加载的类型&quot;&gt;&lt;/a&gt;动态加载的类型&lt;/h3&gt;&lt;p&gt;无论是插件化、热部署还是热修复，这些技术的根源都可是说是动态加载，这也是我把“动态加载”作为这个系列文章主题的原因。&lt;/p&gt;
&lt;p&gt;动态加载，就是在程序运行时，加载外部的可执行文件并运行。这里的运行时就是指应用冷启动并开始工作后；外部可以是可以是SD卡，可以是data目录，也可以是jniLib目录，这些可执行文件是没有随着应用一起编译的。&lt;/p&gt;
&lt;p&gt;Android的动态加载按照工作机制的不同，可以分为虚拟机层动态加载和Native层动态加载两大类。&lt;/p&gt;
&lt;h4 id=&quot;运行在虚拟机&quot;&gt;&lt;a href=&quot;#运行在虚拟机&quot; class=&quot;headerlink&quot; title=&quot;运行在虚拟机&quot;&gt;&lt;/a&gt;运行在虚拟机&lt;/h4&gt;&lt;p&gt;简单来说就是只用JAVA代码搞定的类型。&lt;/p&gt;
&lt;p&gt;基于虚拟机的动态加载技术的核心是类加载器ClassLoader，通过它我们能够加载一些新的类，这种方式也是目前大部分技术文章谈到的加载方式。其中，根据ClassLoader使用方式的不同，又演变出“热部署”、“插件化”、“热修复”等技术。&lt;/p&gt;
&lt;h5 id=&quot;热部署&quot;&gt;&lt;a href=&quot;#热部署&quot; class=&quot;headerlink&quot; title=&quot;热部署&quot;&gt;&lt;/a&gt;热部署&lt;/h5&gt;&lt;p&gt;加载外部可执行文件的ClassLoader实例与原APP的ClassLoader实例是互相独立的（不在同一棵代理树上），加载进来的新的类与原APP（宿主）里存在的类互相独立，根据Java对类的定义，因为这些类的ClassLoader不同，所以他们即便包名和类名一致，或者有继承关系，他们也属于不懂的类。所以以这种方式加载进来的类与原有的类不能互通，不能污染宿主原有的类，适合用来动态加载一些独立的业务，比如一些推广的游戏，在宿主上提供一个入口，用户不需要安装游戏就能运行。因为这种方式起到不用安装就能部署游戏的作用，所以称为热部署。&lt;/p&gt;
&lt;h5 id=&quot;插件化&quot;&gt;&lt;a href=&quot;#插件化&quot; class=&quot;headerlink&quot; title=&quot;插件化&quot;&gt;&lt;/a&gt;插件化&lt;/h5&gt;&lt;p&gt;加载外部可执行文件的ClassLoader实例与宿主的ClassLoader实例不是互相独立的，用宿主的ClassLoader加载过的类就无法从外部可执行文件中再次加载，它们可以共用一个公共库，习惯上把外部可执行文件称为插件。插件里可以存放公共库里一些借口的实现类，可以有一些新的Activity或者Service等组件，可以把一些宿主里的业务挪到插件中，插件可以自主升级，不用随着宿主APP发版。&lt;/p&gt;
&lt;h5 id=&quot;热修复&quot;&gt;&lt;a href=&quot;#热修复&quot; class=&quot;headerlink&quot; title=&quot;热修复&quot;&gt;&lt;/a&gt;热修复&lt;/h5&gt;&lt;p&gt;在使用插件化技术的同时，也可以使用插件中的新的类来替换宿主同名的类，这样就能修复宿主中原有的类存在的BUG。相比插件化，热修复因为不需要考虑组件和res资源的问题，所以相对简单得许多，要保证插件种新的类的加载要在加载宿主中原有类的之前。&lt;/p&gt;
&lt;h5 id=&quot;拆分DEX&quot;&gt;&lt;a href=&quot;#拆分DEX&quot; class=&quot;headerlink&quot; title=&quot;拆分DEX&quot;&gt;&lt;/a&gt;拆分DEX&lt;/h5&gt;&lt;p&gt;相信大家都知道打包DEX时65536方法数超标问题，也就是一个DEX只能有65536个方法，因此有了multi-dex的解决方案，把本来只有一个的DEX，拆分成复数以上的DEX，运行时挨个加载进来，这其实也算是一种动态加载，只不过实现过程对开发者是透明的。&lt;/p&gt;
&lt;p&gt;除此之外，还有另一种拆分DEX是用于减少冷启动的时间的。冷启动是指应用第一次从用户点击到完成初始化工作的全部过程。随着现在APP的体积不断增长，一些APP的DEX文件十分庞大，APP在启动的时候，单单加载所有的DEX文件就需要非常多的耗时，所以用户点击APP的时候会有一个明显的卡顿过程。因此有一种拆分DEX的方案是“拆分一个启动闪屏用的DEX，里面只存放启动闪屏界面需要用到的类，因此非常小，其他类放到其他DEX里面”，启动的时候因为只需要加载闪屏的DEX，所以非常快，APP进入闪屏后，通过异步任务去完成其他DEX的加载，就能消除卡顿的过程。&lt;/p&gt;
&lt;p&gt;第一种拆分DEX是官方支持的，开发者只需要打开multi-dex功能即可；第二种拆分DEX则需要开发者自己设计。&lt;/p&gt;
&lt;p&gt;基于ClassLoader的动态加载都有个共同的特点，就是新的类一旦加载进内存了，就无法再次替换了，所以无法在运行时候升级功能，需要重启APP才能生效。&lt;/p&gt;
&lt;h4 id=&quot;运行在Native&quot;&gt;&lt;a href=&quot;#运行在Native&quot; class=&quot;headerlink&quot; title=&quot;运行在Native&quot;&gt;&lt;/a&gt;运行在Native&lt;/h4&gt;&lt;p&gt;有另一种动态加载方式是工作在Native层的，相比于ClassLoader，在Native层的动态加载不需要重新启动APP就能生效，这类的加载有 加载SO库 和 基于JNI HOOK 的热修复。&lt;/p&gt;
&lt;h5 id=&quot;加载SO库&quot;&gt;&lt;a href=&quot;#加载SO库&quot; class=&quot;headerlink&quot; title=&quot;加载SO库&quot;&gt;&lt;/a&gt;加载SO库&lt;/h5&gt;&lt;p&gt;加载SO库是最常见的Native动态加载，我们项目经常中使用SO库，编译APP的时候，SO并不会参与编译，会原封不动被拷贝到APK包里的lib目录下，安装APK的时候，系统会扫描lib文件夹下支持当前设备CPU类型（比如arm或x86）的SO库（APK包会带有多种CPU类型对应的SO库，安装的时候只需要对应类型的）并拷贝到系统安装目录，APP在运行时可以调用 &lt;code&gt;System#loadLibrary&lt;/code&gt; 方法动态加载对应的SO库，此外还可以调用 &lt;code&gt;System#load&lt;/code&gt; 加载指定路径上的SO库。&lt;/p&gt;
&lt;p&gt;现在的APK里面往往带有非常多的SO库，而APP运行时只需要用到对应CPU类型的SO库，因此把SO库从APK包里剥离出来也是APK瘦身的有效手段。&lt;/p&gt;
&lt;h5 id=&quot;JNI-HOOK&quot;&gt;&lt;a href=&quot;#JNI-HOOK&quot; class=&quot;headerlink&quot; title=&quot;JNI HOOK&quot;&gt;&lt;/a&gt;JNI HOOK&lt;/h5&gt;&lt;p&gt;基于JNI HOOK的热修复技术的代表框架有阿里巴巴的 &lt;strong&gt;AndFix&lt;/strong&gt;。Android中，修复BUG的方式就是更新类的方法，和ClassLoader通过加载新的类来更换方法的实现的想法一样，&lt;strong&gt;AndFix&lt;/strong&gt; 也是通过更换方法的做法来实现热修复，不过做法比较取巧。Android中执行Native方法的时候，会去SO库中查找对应的C/C++方法，而 &lt;strong&gt;AndFix&lt;/strong&gt; 先把普通Java方法用Native方法代替，再通过更换不同SO库还更换Native方法的实现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-8/68653221.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在网络上有许多关于动态加载的介绍的文章，谈及的关键词汇有动态加载、插件化、热部署、热修复等，对于一些刚接触这方面开发技术的人来说，可能容易混淆。&lt;/p&gt;
&lt;p&gt;虽然我在动态加载系列的文章中或多或少有谈到这些概念的区别，但是我觉得认识这些区别对于使用动态加载技术还是挺重要的，所以特别开这个新的文章进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>BILIBILI・生产欢乐的地方</title>
    <link href="http://kaedea.com/2016/05/04/whisper-jobs-bilibili/"/>
    <id>http://kaedea.com/2016/05/04/whisper-jobs-bilibili/</id>
    <published>2016-05-03T16:00:00.000Z</published>
    <updated>2016-06-26T08:13:43.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-4/85797630.jpg&quot; alt=&quot;join us&quot;&gt;&lt;/p&gt;
&lt;p&gt;来B站不到半个月就是开内推了 😂&lt;br&gt;&lt;strong&gt;BiliBili移动技术部&lt;/strong&gt; 开始招兵买马啦，欢迎各位小伙伴加入！🌝🌝🌚（严肃脸）&lt;br&gt;Android开发/iOS开发/算法工程师/产品/运营，中二二次元技术宅集聚地，20-30k，高薪高逼格技术风格、大量绝度领域妹子。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;公司介绍&quot;&gt;&lt;a href=&quot;#公司介绍&quot; class=&quot;headerlink&quot; title=&quot;公司介绍&quot;&gt;&lt;/a&gt;公司介绍&lt;/h4&gt;&lt;p&gt;该网站于2009年6月26日创建哔哩哔哩公司是一家深耕ACG产业的公司，旗下涵盖动漫、游戏及其他ACG衍生文化，其主站bilibili，现为中国大陆用户社区交流最活跃的综合性弹幕视频站。&lt;br&gt;目前B站注册用户超过5000万,相关数据还在不断上升中。&lt;br&gt;bilibili网站初创于2009年6月26日，2010年1月24日正式更名为bilibili，名字来自《魔法禁书目录》中人物御坂美琴的昵称“biribiri”，后被亲切昵称为“B站”。&lt;br&gt;bilibil网站以动漫游戏为主，为用户提供一个稳定的弹幕视频分享平台，旨在打造一个全球性的垂直型泛ACG文化社区。&lt;/p&gt;
&lt;h4 id=&quot;职位&quot;&gt;&lt;a href=&quot;#职位&quot; class=&quot;headerlink&quot; title=&quot;职位&quot;&gt;&lt;/a&gt;职位&lt;/h4&gt;&lt;h5 id=&quot;Android开发攻城狮&quot;&gt;&lt;a href=&quot;#Android开发攻城狮&quot; class=&quot;headerlink&quot; title=&quot;Android开发攻城狮&quot;&gt;&lt;/a&gt;Android开发攻城狮&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;至少一年以上Android平台应用开发经验，具备扎实的 Java 语言基础&lt;/li&gt;
&lt;li&gt;深入了解Android系统框架，UI绘制及渲染、事件传递等机制&lt;/li&gt;
&lt;li&gt;熟悉Android多线程及高性能编程，及有一定的UI、网络、内存的优化经验&lt;/li&gt;
&lt;li&gt;熟悉常见的开源库，了解其实现原理&lt;/li&gt;
&lt;li&gt;熟练使用git进行协同开发。 加分项： 有多媒体应用开发经验&lt;/li&gt;
&lt;li&gt;有独立开发的应用或开源组件或个人博客&lt;/li&gt;
&lt;li&gt;有其他语言经验，如c/c++、groovy、python等&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;Android视频播放器开发攻城狮&quot;&gt;&lt;a href=&quot;#Android视频播放器开发攻城狮&quot; class=&quot;headerlink&quot; title=&quot;Android视频播放器开发攻城狮&quot;&gt;&lt;/a&gt;Android视频播放器开发攻城狮&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;至少两年的Android实际开发经验&lt;/li&gt;
&lt;li&gt;有Android视频播放相关的实际开发经验&lt;/li&gt;
&lt;li&gt;熟悉UI和framework层&lt;/li&gt;
&lt;li&gt;有native层实际开发经验者优先&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;薪资福利&quot;&gt;&lt;a href=&quot;#薪资福利&quot; class=&quot;headerlink&quot; title=&quot;薪资福利&quot;&gt;&lt;/a&gt;薪资福利&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;20K ~ 30K&lt;/li&gt;
&lt;li&gt;交通补贴，住房补贴&lt;/li&gt;
&lt;li&gt;下午茶，生日福利&lt;/li&gt;
&lt;li&gt;二次元特色节日&lt;/li&gt;
&lt;li&gt;BiliBili养猪厂提供的免费零食饮料&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他岗位详情请见：&lt;a href=&quot;http://www.bilibili.com/html/join-list.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;招聘主页&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; class=&quot;headerlink&quot; title=&quot;联系方式&quot;&gt;&lt;/a&gt;联系方式&lt;/h4&gt;&lt;p&gt;邮箱：&lt;a href=&quot;mailto:xiexiaofeng@bilibili.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xiexiaofeng@bilibili.com&lt;/a&gt;, &lt;a href=&quot;mailto:kidhaibara@gmail.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kidhaibara@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i4.piimg.com/fe14309549173955.png&quot; alt=&quot;欢迎您的加入&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-6-4/85797630.jpg&quot; alt=&quot;join us&quot;&gt;&lt;/p&gt;
&lt;p&gt;来B站不到半个月就是开内推了 😂&lt;br&gt;&lt;strong&gt;BiliBili移动技术部&lt;/strong&gt; 开始招兵买马啦，欢迎各位小伙伴加入！🌝🌝🌚（严肃脸）&lt;br&gt;Android开发/iOS开发/算法工程师/产品/运营，中二二次元技术宅集聚地，20-30k，高薪高逼格技术风格、大量绝度领域妹子。&lt;br&gt;
    
    </summary>
    
      <category term="Living" scheme="http://kaedea.com/categories/Living/"/>
    
    
      <category term="BiliBili" scheme="http://kaedea.com/tags/BiliBili/"/>
    
      <category term="工作" scheme="http://kaedea.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>BILIBILI・乾杯</title>
    <link href="http://kaedea.com/2016/05/01/whisper-join-bilibili/"/>
    <id>http://kaedea.com/2016/05/01/whisper-join-bilibili/</id>
    <published>2016-04-30T16:00:00.000Z</published>
    <updated>2016-06-26T08:13:40.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-2/69036480.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我最近搬到BiliBili（B站）总部工作了。&lt;br&gt;虽然今天才刚刚到了五月，不过我的五月病已经发作了好几个月了。&lt;br&gt;最近一段时间一直处理咸鱼状态，因为发生了一接连不愉快的事情，让我无从淡定……&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要说的是为何决定换工作。&lt;br&gt;其实在YY的工作还是不错的，只不过许多时候我们总是希望自己能和团队一起成长，但是我看不到这些东西，所以就产生了离职的念头。&lt;br&gt;B站的工作机会是我在校的时候就开始考虑的，只不过毕竟在魔都，没那个决心。&lt;br&gt;后来慢慢接触到了B站的人，觉得他们的 &lt;strong&gt;社团氛围&lt;/strong&gt; 还是挺吸引我的，所以就投了这边的简历，后来通过和Ctiao老司机和娜妍Yrom进行了交易，顺利地拿到了Offer。&lt;/p&gt;
&lt;p&gt;不过拿到Offer和真正换工作又是另外一回事了。&lt;br&gt;本来和B站的HR约好是一个月以后入职的，这样我从YY离职后还有半个月的休息时间，再从广州跑去上海入职。不过年后YY正在发版手机YY5.0这个全新的版本，所以比较紧张，一时半会无法脱身，等到开始走离职流程已经是3月下旬了。而我到B站入职的时间是清明节后，所以这里我有创造了一项纪录，就是 &lt;strong&gt;4月1号离职，4月5号入职&lt;/strong&gt;。其中2号到4号是清明节，也就是说我 &lt;strong&gt;无缝对接&lt;/strong&gt; 地换了一份工作，而且是从广州到上海。具体过程就是，1号离职，2号搬东西回老家，3号飞往上海，4号休息一天，5号入职。说实在，但是给我的直接感受就是“如果再让我选择一次，我就没那么淡定要换工作了”。&lt;/p&gt;
&lt;p&gt;不过有一件事情我还是大意了。&lt;br&gt;魔都的房租相比妖都真是贵得离谱，特别是浦东陆家嘴这边，而B站的总部就在这里。目前我和找了一间普通的民房租下，租金是3000软妹币/月，和一个有女装爱好的奇怪的舍友合租。相比我在妖都800/月的房租，这边的压力到现在我还是无法接受。&lt;/p&gt;
&lt;p&gt;总之，入职快一个月了，忙着各种熟悉项目，忙着搬家，忙着买各种装备，忙着纠结对妹子的恋心（好想有什么奇怪的东西混进来了）…… 捉着青春的尾巴，再努力一把！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-5-2/69036480.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我最近搬到BiliBili（B站）总部工作了。&lt;br&gt;虽然今天才刚刚到了五月，不过我的五月病已经发作了好几个月了。&lt;br&gt;最近一段时间一直处理咸鱼状态，因为发生了一接连不愉快的事情，让我无从淡定……&lt;br&gt;
    
    </summary>
    
      <category term="Living" scheme="http://kaedea.com/categories/Living/"/>
    
    
      <category term="BiliBili" scheme="http://kaedea.com/tags/BiliBili/"/>
    
      <category term="工作" scheme="http://kaedea.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Learning in Android</title>
    <link href="http://kaedea.com/2016/02/13/whisper-learning-in-android/"/>
    <id>http://kaedea.com/2016/02/13/whisper-learning-in-android/</id>
    <published>2016-02-12T20:06:18.000Z</published>
    <updated>2016-06-26T08:13:36.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/92657099.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3年Android程序设计的自我吐槽&lt;/p&gt;
&lt;p&gt;春节期间，因为使用VPN梯子的姿势不对，导致Chrome的Google书签和xMarks书签发生了冲突，所以有一些重要的书签可能丢失了，我需要整理一下。看了一边满屏的技术教程，顿时产生了颇多的思绪。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Okay，来看看都有哪些书签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/72398406.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿，不知不觉已经1500+个书签项了，好在我平时都有好好分类，所以不是那么的混乱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/20659991.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;学习Android姿势之前，我是主攻C#.Net开发的，其优美的WPF程序和强大的Visual Studio让我无法抗拒，来看看有哪些书签吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/8996260.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2333333，我学习C#的时候有看那么多教程么。虽然这些教程在大神们看来都是非常Naive的技术姿势，但是我现在看起来还是觉得非常的温馨呀。好想在C#上再大♂干一场呢，WP你什么时候能争点气啊，巨硬等你君临天下那一天，我肯定第一时间抱回C#。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/81085717.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;什么？为什么现在不转回C#？66666666，当年害得我毕业差点找不到工作好不好。&lt;/p&gt;
&lt;p&gt;再看看这个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/73799996.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我了个大去的，又一个黑历史。当年中二病严重期，还是学了不少图像处理和视频剪辑的，没错，上面的视频教程我可是基本都看过了，那时候觉得看视频教程比看单纯图文的开发技术教程有趣多了。&lt;/p&gt;
&lt;p&gt;这不就是我公司追求的理念“富集通讯”么，666666。&lt;/p&gt;
&lt;p&gt;看看我这黑历史期间都捣鼓了哪些东西。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Magia Bustrers!EX&lt;/code&gt;&lt;/p&gt;
&lt;embed height=&quot;452&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;http://share.acg.tv/flash.swf&quot; flashvars=&quot;aid=90585&amp;page=1&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;code&gt;山寨版超威葛炮PV&lt;/code&gt;&lt;/p&gt;
&lt;embed height=&quot;452&quot; width=&quot;544&quot; quality=&quot;high&quot; allowfullscreen=&quot;true&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;http://share.acg.tv/flash.swf&quot; flashvars=&quot;aid=45268&amp;page=1&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot;&gt;

&lt;p&gt;这都TM的啥跟啥啊，2333333。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/33179828.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后当然不能少了Android啊。&lt;/p&gt;
&lt;p&gt;我是2012年暑假的时候开始在学校的暑期培训课上学习Android姿势的，2013年春节过后开始正式的Android程序设计，一开始也是看了不少的博客教程，简直就像打开了一个新世界的大门，怎么学都觉得姿势不够用。不过说实话，一开始我是一边臭骂着Eclipse一边学Android的，Visual Studio不知道比这货高明到哪里去了，这情况一直持续到Android Studio开始够用之后。&lt;/p&gt;
&lt;p&gt;“安德罗伊德”的好处都有啥，谁说对了就给他，麻麻的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/80300363.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;还是老样子，麻麻密密的，233333。不过Android的书签可比C#多多了，所以都不得不用起了分类来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/24759708.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个分类和命名方式是一开始学Android时想出来的方案，到现在一直没变。后来Android的书签实在是太多了，我就琢磨着是不是该做减法了，所以又出现了更加系统的分类方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/62229931.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些书签每当我重新看一次的时候，都会觉得那时候自己怎么那么笨啊，2333333。不过即使这样我还是舍不得删掉，只有当书签地址打不开了我才会删掉它。这些书签和我的技术笔记一样，都是组成个人知识管理系统的一部分，虽然有时候可能没什么用，但是毕竟记录了一个中二患者成长的过程，这是一个在无限挖坑与填坑中斗争的过程，它应该被铭记。&lt;/p&gt;
&lt;p&gt;今天再次整理了一下书签，我还是能够深刻感受到，那时候正在学习姿势的心中的那一份莫名其妙的鼓动。假如，大学还能重来一次，那我一定会毫不犹豫地选择——日本语！！！！去你妹的开发！去你妹的技术！去你妹的知识！这就是一个大坑，一个无底洞，去你妹的“科技是第一生产力”，把这些时间和精力都用来学习日本语的话，劳资的能力早就吊打原生的霓虹人了，劳资早就能撩到卡哇伊的日本妹子了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/3861860.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;アンドロイド何かﾀﾞｰｲヾ(*‘ω’*)ﾉｷﾗｲｯ、開発何か(　ﾟДﾟ)＜氏ね！&lt;/p&gt;
&lt;!-- css --&gt;
&lt;style type=&quot;text/css&quot;&gt;
embed {
   display: block;
   margin:  10px auto 10px auto;
}
&lt;/style&gt;

&lt;!-- last edit --&gt;
&lt;!-- 2016-2-13 03:59:16 --&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-13/92657099.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3年Android程序设计的自我吐槽&lt;/p&gt;
&lt;p&gt;春节期间，因为使用VPN梯子的姿势不对，导致Chrome的Google书签和xMarks书签发生了冲突，所以有一些重要的书签可能丢失了，我需要整理一下。看了一边满屏的技术教程，顿时产生了颇多的思绪。&lt;br&gt;
    
    </summary>
    
      <category term="Living" scheme="http://kaedea.com/categories/Living/"/>
    
    
      <category term="吐槽" scheme="http://kaedea.com/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>阅读ANDROID源码的一些姿势</title>
    <link href="http://kaedea.com/2016/02/09/android-about-source-code-how-to-read/"/>
    <id>http://kaedea.com/2016/02/09/android-about-source-code-how-to-read/</id>
    <published>2016-02-09T09:44:55.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/47582414.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面吐槽了 &lt;a href=&quot;http://kaedea.com/2016/02/08/android-about-source-code/&quot;&gt;有没有必要阅读Android源码&lt;/a&gt;，后面觉得只吐槽不太好，还是应该多少弄点干货。需要说明的是，Android每个系统版本的源码都会有变动，而且代码中时不时Java和Native互相穿插，追求完全看透源码意义不大，把目的定在“理解代码设计的思路，弄清各个生命周期方法调用的顺序”比较实际。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;日常开发中怎么阅读源码&quot;&gt;&lt;a href=&quot;#日常开发中怎么阅读源码&quot; class=&quot;headerlink&quot; title=&quot;日常开发中怎么阅读源码&quot;&gt;&lt;/a&gt;日常开发中怎么阅读源码&lt;/h2&gt;&lt;h3 id=&quot;找到正确的源码&quot;&gt;&lt;a href=&quot;#找到正确的源码&quot; class=&quot;headerlink&quot; title=&quot;找到正确的源码&quot;&gt;&lt;/a&gt;找到正确的源码&lt;/h3&gt;&lt;p&gt;IDE是日常经常用的东西，Eclipse就不说了，直接从Android Studio（基于IntelliJ Community版本改造）开始。&lt;/p&gt;
&lt;p&gt;我们平时的Android项目，都是要依赖Android SDK里对应API Level的android.jar包（而且是以Provided的形式依赖），这样才能使用Android提供的API。在IntelliJ中，当想要看具体类的源码的时候，如果Android SDK里对应API Level的Source包有下载的话，IDE会打开对应的Source包；如果还没有下载，IDE会把对应API Level的android.jar包反编译成Java代码，这个规则对于一些第三方的开源项目也一样。推荐下载Source源码，毕竟反编译的Java代码不可能完全和源码的时候一样，有时候反编译出来的代码的执行逻辑可能完全等价，但是可阅读性下降了不好，而且也少了一些重要的注释。&lt;/p&gt;
&lt;p&gt;定位具体源码的时候，可以通过“Ctrl+鼠标左键”来查看，也可以通过“双击Shift”，在查找框里输入目标类的名字来定位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/89744598.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，第一个类就是API23的NinePatchDrawable的源码，第二个就是通过android.jar反编译而来的，这里记得把“Include non-project items”勾上。&lt;/p&gt;
&lt;h3 id=&quot;关于SDK自带的源码和隐藏API&quot;&gt;&lt;a href=&quot;#关于SDK自带的源码和隐藏API&quot; class=&quot;headerlink&quot; title=&quot;关于SDK自带的源码和隐藏API&quot;&gt;&lt;/a&gt;关于SDK自带的源码和隐藏API&lt;/h3&gt;&lt;p&gt;Android SDK自带的Source源码包很小，并没有包括所有的Android Framework的源码，仅仅提供给应用开发参考用，一些比较少用的系统类的源码并没有给出，所以有时候你会看到如下。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; URL &lt;span class=&quot;title&quot;&gt;findResource&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Stub!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;“RuntimeException(“Stub!”)”表示实际运行时的逻辑会由Android ROM里面相同的类代替执行。&lt;/p&gt;
&lt;p&gt;此外，在IDE里看源码的时候，有时候一些方法或者类会出现报红（找不到）的情况，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/89825596.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是因为这些方法或者类是被Android SDK隐藏的，出于安全或者某些原因，这些API不能暴露给应用层的开发者，所以编译完成的android.jar包里会把这些API隐藏掉，而我们的Android项目是依赖android.jar的，查看源码的时候，IDE会自动去android.jar找对应的API，自然会找不到。当然，这些API在ROM中是实际存在的，有些开发者发现了一些可以修改系统行为的隐藏API，在应用层通过反射的方式强行调用这些API执行系统功能，这种手段也是一种HACK。&lt;/p&gt;
&lt;h3 id=&quot;Google的AOSP项目&quot;&gt;&lt;a href=&quot;#Google的AOSP项目&quot; class=&quot;headerlink&quot; title=&quot;Google的AOSP项目&quot;&gt;&lt;/a&gt;Google的AOSP项目&lt;/h3&gt;&lt;p&gt;当你需要的源码在Android SDK Source中找不到的时候，就有必要去&lt;a href=&quot;https://android.googlesource.com/?format=HTML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AOSP&lt;/a&gt;（Android Open Source Project）项目里面找了。&lt;/p&gt;
&lt;p&gt;不过AOSP项目包括整个Android所有开源的东西，实在是太庞大了，对于一般开发者来说，我们只需要接触Framework层次的东西就够了，这里包括了base、build-tools、support包甚至Volley项目的源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/53056079.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以base为例，进入base目录，能看到base项目的git仓库，左边是其所有的分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/70376864.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入“master/core/java/android/”路径就能看到熟悉的Package目录了，其他分支以及项目都类似。有必要的时候可以把整个AOSP项目Clone下来，大概20G左右，可以把项目导入到IDE里面，这样就更方便查看源码了，另外可以可是试着编译自己的Android ROM，只需要部署能够跑MakeFile命令的环境就好。&lt;/p&gt;
&lt;h3 id=&quot;一些辅助阅读的工具&quot;&gt;&lt;a href=&quot;#一些辅助阅读的工具&quot; class=&quot;headerlink&quot; title=&quot;一些辅助阅读的工具&quot;&gt;&lt;/a&gt;一些辅助阅读的工具&lt;/h3&gt;&lt;h4 id=&quot;Chrome扩展&quot;&gt;&lt;a href=&quot;#Chrome扩展&quot; class=&quot;headerlink&quot; title=&quot;Chrome扩展&quot;&gt;&lt;/a&gt;Chrome扩展&lt;/h4&gt;&lt;p&gt;Android SDK Search&lt;br&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/73121661.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;相信平时到 &lt;a href=&quot;http://developer.android.com/reference/classes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android开发者官网&lt;/a&gt; 查看API说明的人不少，这个扩展可以在API类名旁边显示一个跳转链接，用于跳转到AOSP中对应的类的源码，方便查看源码。&lt;/p&gt;
&lt;h4 id=&quot;Source-Insight&quot;&gt;&lt;a href=&quot;#Source-Insight&quot; class=&quot;headerlink&quot; title=&quot;Source Insight&quot;&gt;&lt;/a&gt;Source Insight&lt;/h4&gt;&lt;p&gt;在这个工具帮助下，你才可以驾驭巨大数量的Android 源码，你可以从容在Java，C++,C代码间遨游，你可以很快找到你需要的继承和调用关系。&lt;/p&gt;
&lt;h4 id=&quot;VPN梯子&quot;&gt;&lt;a href=&quot;#VPN梯子&quot; class=&quot;headerlink&quot; title=&quot;VPN梯子&quot;&gt;&lt;/a&gt;VPN梯子&lt;/h4&gt;&lt;p&gt;善用梯子是开发者基本的自我修养之一，如果你不想做“面向百度编程”的话。&lt;/p&gt;
&lt;p&gt;我在一开始是使用免费的GoAgent和WallProxy，但是经常要更新，而且最近还要经常替换IP才能工作，所以后来我换成了收费的ShadowSocks，各个平台都有客户端，非常方便，我也在手机上常态用起了Google的全家桶，只不过最近老是更换服务器地址，而且部分服务器不稳定，非常担心商家是否准备捞一笔然后跑路，23333。&lt;/p&gt;
&lt;p&gt;我觉得比起折腾找免费的低速、不稳定的梯子，还是用一些稳定的收费的的梯子比较划算。至于具体的用梯子的姿势，请诸位自行搜索，这里随便贴个介绍 &lt;a href=&quot;http://weibo.com/2491729875/CcNaY2Rbt?from=page_1005052491729875_profile&amp;amp;wvr=6&amp;amp;mod=weibotime&amp;amp;type=comment#_rnd1431747713302&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;梯子使用总结&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读的源码&quot;&gt;&lt;a href=&quot;#推荐阅读的源码&quot; class=&quot;headerlink&quot; title=&quot;推荐阅读的源码&quot;&gt;&lt;/a&gt;推荐阅读的源码&lt;/h2&gt;&lt;p&gt;AOSP项目这么庞大，就算是Framework部分也有够看上一阵子的，所以推荐从常用的看起，由浅及深，同时向横向和纵向深入阅读。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Handler-Message-Looper&lt;/strong&gt;&lt;br&gt;Handler被称为“异步提交器”，是Android开发入门教程必定谈及的东西，这也是Activity等组件的工作机制需要用到的东西，是“数据驱动”框架的重要组成，作为阅读源码的入门最适合不过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Activity和Service&lt;/strong&gt;&lt;br&gt;作为经常使用到的组件，阅读其源码的花费和带来的技术提高的性价比肯定是最高的，Service可以不看，但是Activity总不能少吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fragment&lt;/strong&gt;&lt;br&gt;还在认为Fragment是一个视图吗，还在认为FragmentActivity的界面有多个Fragment组成吗，看看Fragment和FragmentManager吧，了解下生命周期的本质到底是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;View&lt;/strong&gt;&lt;br&gt;想自定义高级的View类吗，那总得知道onMeasure/onLayout/onDraw这些方法是怎么被调用的，了解LayoutParams是怎么工作的，知道调用requestLayout和Invalidate的时候有什么区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MotionEvent&lt;/strong&gt;&lt;br&gt;在懂的怎么自定义高级的View后，只能向用户显示界面，还得知道怎么与用户交互才能做出华丽的UI。所以必须知道TouchEvent的分发和拦截的工作机制，起码也得知道其特点，才不会一直在困扰“为什么无法监听用户的触摸事件”、“View之间的触摸事件冲突了”或者“View的滑动与点击事件冲突了”之类的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LayoutInflator&lt;/strong&gt;&lt;br&gt;布局渲染器也是开发Android UI的时候经常用到的，不过LayoutInflator实例的创建方式有好几种，你至少得知道其之间的区别。还有，LayoutInflator在渲染指定布局的时候，有container和attachToRoot等参数，阅读源码后很快能了解其区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SurfaceView和TextureView&lt;/strong&gt;&lt;br&gt;阅读完View的工作机制后，就能理解为什么View在绘制复杂的UI效果时效率这么低，这时候就需要SurfaceView和TextureView了。理解双缓冲对UI更新效率的帮助，了解SurfaceView在视图叠加的时候的缺陷，了解TextureView在Android Lollipop之前的内容窜台BUG，才能用正确姿势使用这俩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AsyncTask&lt;/strong&gt;&lt;br&gt;异步任务也是Android开发经常遇到的问题，相比自己从Thread和Handler写起，被称为“异步任务大师”的AsyncTask类自然更受到许多小伙伴的喜欢。不过AsyncTask在早期的Android版本中差别甚大，需要做大量的适配工作，而且特别容易引起异步任务引用着组件的实例导致内存泄露从而引发OOM问题，所以不推荐直接使用AsyncTask类，不过强烈推荐阅读AsyncTask的源码学习Google优秀的异步任务设计理念。此外，如果真的要使用AsyncTask，不要直接使用系统提供的AsyncTask类，AsyncTask本身就是一个单一的Java类，没有耦合其他系统类，推荐自己从最新的Android版本中复制一份AsyncTask类的代码，自己维护，在项目中当做Support包一样使用，以规避其兼容性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Volley&lt;/strong&gt;&lt;br&gt;这个强烈推荐，是Google官方的异步任务框架，没有随Android发布，需要自己在Framework里下载代码。Volley的中文意思就是“并发”，阅读其源码能让你见识到原来异步任务框架也能写得这么低耦合和高扩扩展，其用“生产者-消费者”模式来处理异步请求的框架会让人拍案叫绝。此外，Volley框架是用于处理Http任务和Image加载任务，但是其优秀的异步控制思想也能运用与File、Sqlite等耗时任务的处理，当你能够自己写出类似Volley框架的代码时，说明你的Android技术已经有所突破。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;android.util.*&lt;/strong&gt;&lt;br&gt;“android.util.*” 包名下有许多优秀的实用类，大多是作为Java自带类的补充，比如数据结构类的SparseArray、ArrayMap、ArraySet，用于加密的Base64，用于处理屏幕分辨率自适应的DisplayMetrics和TypedValue，用于时间换算的TimeUtils，以及用于内存缓存的LruCache，熟悉这些类对Android开发非常有帮助，也会让代码显得成熟。&lt;/p&gt;
&lt;h3 id=&quot;进阶&quot;&gt;&lt;a href=&quot;#进阶&quot; class=&quot;headerlink&quot; title=&quot;进阶&quot;&gt;&lt;/a&gt;进阶&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;br&gt;阅读Context源码能帮助我们了解其工作机制，了解Google是怎么在Java代码上添加Android特性的，了解Android是怎么保存和获取res资源的，了解ContextWrapper和Activity这些Context有什么区别，了解Context设计的装饰者模式（Description Pattern）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ClassLoader&lt;/strong&gt;&lt;br&gt;类加载器ClassLoader是Android虚拟机工作的基础，了解其“双亲代理模式”能让你更好的了解系统的类和你写的类是怎么工作的。Multi-Dex和ART模式也和ClassLoader的工作机制息息相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binder&lt;/strong&gt;&lt;br&gt;Binder是Android上RPC（Remote Procedure Call Protocol）的实现，Android系统许多功能就是居于Binder实现的，平时应用层对Binder的使用大多是在于和Service通讯的时候，不过，当我们需要使用AIDL功能的时候，就需要接触到Binder了。（推荐阅读原理即可，反正C++驱动层我是看不下去了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WMS，AMS，PMS，NMS，IMS等系统Service&lt;/strong&gt;&lt;br&gt;SystemServer是Android的Framework层工作的核心，Android系统启动过程包含从Linux内核加载到Home应用程序启动的整个过程。SystemServer是Zygnote孵化的第一个进程，这个进程会启动许多Framework层功能需要用到的线程，比如用于管理窗口的WindowManagerService，用于管理Activity的ActivityManagerService，用于管理APK包信息的PackageManagerService，用于管理网络的NetworkManager，用于处理用户触摸的InputManagerService等，这些系统Service提供了APP运行时需要的大多系统功能，大多使用“stub-server”的模式进行交互，而且有大量的JNI的调用。这部分的源码比较适合从事ROM开发的人阅读，应用层的开发基本不会用到，但是这方面的只是能让我们对Android Framework层的工作机制有个大抵的认识。（非常惭愧，这部分我自己看了几次，还是没能产生融会贯通的感觉，整体的认识还是比较模糊，希望继续跟着老罗的博客，捡捡肉吃）&lt;/p&gt;
&lt;h3 id=&quot;第三方开源项目&quot;&gt;&lt;a href=&quot;#第三方开源项目&quot; class=&quot;headerlink&quot; title=&quot;第三方开源项目&quot;&gt;&lt;/a&gt;第三方开源项目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;EventBus&lt;/strong&gt;&lt;br&gt;Android上的一个“订阅者-发布者”模式的实现框架，非常适合业务多而且经常变动的项目，能够有效预防“接口爆炸”，现在基本上中型以上的项目都会采用类似的框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OTTO&lt;/strong&gt;&lt;br&gt;同上，只不过实现的具体方案不一样，而且OTTO相比EventBus来，比较小巧，代码也比较简练，非常适合处女座的开发者食用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RxJava&lt;/strong&gt;&lt;br&gt;相比起上面两个，RxJava可以说是把异步的思想发挥到了极致，RxJava的兴起代表了Android开发中响应式编程的崛起，同样非常适合业务多而且经常变动的项目，只不过相比传统的基于接口的开发方式，RxJava框架的开发方式会有点难以适应，特别是团队开发的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guava&lt;/strong&gt;&lt;br&gt;这个其实也是Google自己开源的，提供了许多优秀的Java工具类，比如“one to one mapping”的Bimap，有时候一些工具类Android或Java自带的库没有提供，或许我们可以先参考Guava的。&lt;/p&gt;
&lt;p&gt;以上是我自己个人推荐阅读的源码，不过每个开发者自身的兴趣和侧重点都不一样，有兴趣的参考着看就是。同时，如果有一些有趣的系统类，随时欢迎推荐给我。&lt;/p&gt;
&lt;h2 id=&quot;站在巨人的肩膀上阅读&quot;&gt;&lt;a href=&quot;#站在巨人的肩膀上阅读&quot; class=&quot;headerlink&quot; title=&quot;站在巨人的肩膀上阅读&quot;&gt;&lt;/a&gt;站在巨人的肩膀上阅读&lt;/h2&gt;&lt;p&gt;学习一个系统最好的方法就是“Read The Fucking Source Code”，坏消息是AOSP项目是在太庞大太难消化了，好消息就是现在已经有不少先驱，我们或许可以站在他们的肩膀上阅读。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://source.android.com/source/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AOSP官方的介绍&lt;/a&gt;&lt;br&gt;项目介绍, 代码下载, 环境搭建, 刷机方法, Eclipse配置都在这里，这是一切的基础。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方教程&lt;/a&gt; 和 &lt;a href=&quot;http://android-developers.blogspot.jp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方博客&lt;/a&gt;&lt;br&gt;这个其实是给App开发者看的，但是里面也有不少关于系统机制的介绍, 值得细读。而官方博客经常有一些开发者容易疏忽的姿势的讨论，比如“Bitmap数据的回收问题”，推荐阅读。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/android/issues/list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Issues&lt;/a&gt;&lt;br&gt;Android官方Issue列表，记录一些系统BUG，别掉坑里了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;老罗的Android之旅&lt;/a&gt;&lt;br&gt;此老罗非彼老罗,罗升阳老师的博客非常有营养,基本可以作为指引你开始阅读AOSP源码的教程。你可以按照博客的时间顺序一篇篇挑需要的看。但这个系列的博客有些问题：早期的博客是基于旧版本的Android;&lt;br&gt;大量的代码流程追踪。读文章时你一定要清楚你在看的东西在整个系统处于什么样的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/2827740.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时推荐老罗的这本书，平时看博客就可以，无聊的时候，比如在动车上可以把这本书翻翻。（非常优秀的书，不过据本人描述，这本书稿费还抵不会出版费）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/innost&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Innost的专栏&lt;/a&gt;&lt;br&gt;邓凡平老师也是为Android大牛, 博客同样很有营养。但是不像罗升阳老师的那么系统， 更多的是一些技术点的深入探讨。&lt;/p&gt;
&lt;h2 id=&quot;阅读时的姿势&quot;&gt;&lt;a href=&quot;#阅读时的姿势&quot; class=&quot;headerlink&quot; title=&quot;阅读时的姿势&quot;&gt;&lt;/a&gt;阅读时的姿势&lt;/h2&gt;&lt;p&gt;现在的问题是：当你拿到一份几G的源码，该从哪里开始呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;著作权归作者所有。&lt;br&gt;商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br&gt;作者：墨小西&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/19759722/answer/17019083&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/19759722/answer/17019083&lt;/a&gt;&lt;br&gt;来源：知乎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;宏观上看，Android源码分为功能实现上的纵向，和功能拓展上的横向。&quot;&gt;&lt;a href=&quot;#宏观上看，Android源码分为功能实现上的纵向，和功能拓展上的横向。&quot; class=&quot;headerlink&quot; title=&quot;宏观上看，Android源码分为功能实现上的纵向，和功能拓展上的横向。&quot;&gt;&lt;/a&gt;宏观上看，Android源码分为功能实现上的纵向，和功能拓展上的横向。&lt;/h3&gt;&lt;p&gt;在阅读源码时需要把握好着两个思路。譬如你需要研究音频系统的实现原理，纵向：你需要从一个音乐的开始播放追踪，一路下来，你发现解码库的调用，共享内存的创建和使用，路由的切换，音频输入设备的开启，音频流的开始。譬如你要看音频系统包括哪些内容，横向：通过Framework的接口，你会发现，音频系统主要包括：放音，录音，路由切换，音效处理等。&lt;/p&gt;
&lt;h3 id=&quot;Android的功能模块绝大部分是C-S架构&quot;&gt;&lt;a href=&quot;#Android的功能模块绝大部分是C-S架构&quot; class=&quot;headerlink&quot; title=&quot;Android的功能模块绝大部分是C/S架构&quot;&gt;&lt;/a&gt;Android的功能模块绝大部分是C/S架构&lt;/h3&gt;&lt;p&gt;你心里一定需要有这个层级关系，你需要思路清晰地找到Server的位置，它才是你需要攻破的城，上面的libraries是不是很亲切的样子？看完它长成啥样后，然后你才能发现HAL和Kernel一层层地剥离。很多研究源码的同学兜兜转转，始终在JAVA层上，这是不科学的，要知道libraries才是它的精髓啊。&lt;/p&gt;
&lt;h3 id=&quot;Android的底层是Linux-Kernel。&quot;&gt;&lt;a href=&quot;#Android的底层是Linux-Kernel。&quot; class=&quot;headerlink&quot; title=&quot;Android的底层是Linux Kernel。&quot;&gt;&lt;/a&gt;Android的底层是Linux Kernel。&lt;/h3&gt;&lt;p&gt;在理解上面两点之后，还是需要对Kernel部分有个简单的理解，起码你要熟悉kernel的基础协议吧！你要能看懂电路图吧！你要熟悉设备的开启和关闭吧！你要熟悉调寄存器了吧！这方面的书太多了，我建议根据实例去阅读，它并不复杂，不需要一本本厚书来铺垫。在libraries和kernel间，可能还会有个HAL的东东，其实它是对kernel层的封装，方便各个硬件的接口统一。这样，如果我换个硬件，不用跑了长得很复杂的libraries里面改了，kernel调试好了后，改改HAL就好了。&lt;/p&gt;
&lt;p&gt;好了，你现在是不是跃跃欲试准备去找个突破口准备进攻了，但是好像每个宝库的入口都挺难找了我大概在三个月前阅读完Android UI系统的源码，这是Android最复杂的部分，我要简单说下过程。我需要先找宝库入口，我要研究UI，首先要找什么和UI有亲戚关系吧！View大神跳出来了，沿着它往下找找看，发现它在贴图在画各种形状，但是它在哪里画呢，马良也要纸吧？很明显它就是某个宝藏，但是世人只是向我们描述了它有多美，却无人知在哪里？我们需要找一张地图罗。开发Android的同学逃不掉Activity吧！它有个setcontentview的方法，从这个名字看好像它是把view和activity结合的地方。赶紧看它的实现和被调用，然后我们就发现了Window，ViewRoot和WindowManager的身影，沿着WM和WMS我们就惊喜会发现了Surface，以及draw的函数，它居然在一个DeCorView上画东西哈。借助Source Insight， UI Java层的横向静态图呼之欲出了。完成这个静态UML，我觉得我可以开始功能实现上追踪了，这部分主要是C++的代码（这也是我坚定劝阻的放弃Eclipse的原因），我沿着draw函数，看到了各个层级的关系，SurfaceSession的控制和事务处理，SharedBuffer读写控制，彪悍的SurfaceFlinger主宰一切，OpenGL ES的神笔马良。FrameBuffer和FrameBufferDevice的图像输出，LCD设备打开后，开始接收FBD发过来的一帧帧图像，神奇吧。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19759722&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎：大牛们是怎么阅读 Android 系统源码的？&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-9/47582414.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面吐槽了 &lt;a href=&quot;http://kaedea.com/2016/02/08/android-about-source-code/&quot;&gt;有没有必要阅读Android源码&lt;/a&gt;，后面觉得只吐槽不太好，还是应该多少弄点干货。需要说明的是，Android每个系统版本的源码都会有变动，而且代码中时不时Java和Native互相穿插，追求完全看透源码意义不大，把目的定在“理解代码设计的思路，弄清各个生命周期方法调用的顺序”比较实际。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="源码" scheme="http://kaedea.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>有没有必要阅读ANDROID源码</title>
    <link href="http://kaedea.com/2016/02/08/android-about-source-code/"/>
    <id>http://kaedea.com/2016/02/08/android-about-source-code/</id>
    <published>2016-02-07T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-8/20986738.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;或许对于许多Android开发者来说，所谓的Android工程师的工作“不过就是用XML实现设计师的美术图，用JSON解析服务器的数据，再把数据显示到界面上”就好了，源码什么的，看也好不看也罢，反正应用层的开发用不上，再加上现在优秀的轮子越来越多，拿来主义泛滥，能用就是，反正老板也不关心是不是你自己写的，用我现在老大的话来说，阅读源码似乎只是一种“锦上添花”的事，有自然好，没有也罢。&lt;/p&gt;
&lt;p&gt;那么，作为Android开发者的自我修养，到底有没有必要阅读AOSP以及其他开源项目的源码呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;刚开始时候的故事&quot;&gt;&lt;a href=&quot;#刚开始时候的故事&quot; class=&quot;headerlink&quot; title=&quot;刚开始时候的故事&quot;&gt;&lt;/a&gt;刚开始时候的故事&lt;/h2&gt;&lt;p&gt;对于我来说，选择编程是因为我看见了 &lt;a href=&quot;http://moeloader.sinaapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MoeLoader&lt;/a&gt; 这款收图应用实在是漂亮才开始写代码，我要的目的只是应用漂亮，不用在乎代码写成什么样，而且我觉得代码是我写的，这么辛苦的作品可不能白白开源给别人看。所以对于这个时候的我，那时候虽然没有考虑过类似的问题，但是很可能觉得阅读源码是没有必要的。&lt;/p&gt;
&lt;p&gt;后来我开始学习Android，原因非常简单，C#根本无法找到合适的工作，而学生党我的我根本无法买得起苹果三套件，此外，IE6的兼容工作让我实在是对前端敬而远之，所以选择只剩下Android了。说实在的，一开始我是不太喜欢Android开发，特别是IDE从Visual Studio切换到万恶的Eclipse，丑，卡顿，动不动就找不到依赖，甚至有时候编译一直报红Error，定位了半天找不到问题，到最后把红色的Error删除掉后居然就编译通过了！这时候的我，别说阅读源码了，我只求同一份代码在运行的时候有同样的逻辑就好。&lt;/p&gt;
&lt;p&gt;再到后来，我已经有一些Android程序设计的经验了，IDE也开始换到Android Studio（Preview版本刚出来的时候，我在Android Studio和Eclipse之间切换过好几次，不得不说习惯这种东西有时很有帮助，有时候也会很可怕），换到Android Studio很大一个原因是因为Github上面许多开源项目用Android Studio来部署很方便。这个时候我接触的开源项目已经比较多了，许多时候一些开源项目总有一些BUG，我会给其提交ISSUE，不过更多时候我不能等项目所有者来解决，需要我自己解决BUG；许多时候开源项目并不能直接满足业务的需要，所以我也需要先阅读源码再改造成自己的项目能用的。&lt;/p&gt;
&lt;p&gt;这里需要特别说明的是，我的第一份工作的项目是一个SDK项目，整体使用了基于ClassLoader的动态加载的框架。那时候还比较早，国外对动态加载不感兴趣，国内的话也只有零星的技术博客对这有讨论，不过大多是介绍如何实现动态加载而没有分析其工作机制。所以，当有新的技术需求，或者项目出现BUG的时候，我都需要自己阅读源码去解决问题。比如，有一次设计师需要一个全圆角的菜单背景，然而Android的点九图是X轴和Y轴都需要拉伸的，当Y轴拉伸的时候就无法实现全圆角。我能做的就是，先把点九图的原图等比缩放到Y轴填满，这样Y轴就不会被拉伸了，但是原图缩放后，点九图X轴的拉伸却出现了扭曲的样式。通过阅读NinePatchDrawable的源码，我发现点九图的原理就是一个普通的Drawable加上一个用于描述拉伸坐标的数组chunk，当我缩放Drawable的时候，也必须更新chunk，不然拉伸的坐标就对不上，后面通过阅读源码中关于chunk的描述，把对应的拉伸坐标更新后，&lt;strong&gt;全圆角的点九图&lt;/strong&gt; 也就实现了。&lt;/p&gt;
&lt;h2 id=&quot;为什么要阅读源码&quot;&gt;&lt;a href=&quot;#为什么要阅读源码&quot; class=&quot;headerlink&quot; title=&quot;为什么要阅读源码&quot;&gt;&lt;/a&gt;为什么要阅读源码&lt;/h2&gt;&lt;p&gt;说了这么多，到底有没有必要阅读源码？有必要，而且非常有必要！原因有三。&lt;/p&gt;
&lt;h3 id=&quot;其一，了解基层，高层才能更好地工作。&quot;&gt;&lt;a href=&quot;#其一，了解基层，高层才能更好地工作。&quot; class=&quot;headerlink&quot; title=&quot;其一，了解基层，高层才能更好地工作。&quot;&gt;&lt;/a&gt;其一，了解基层，高层才能更好地工作。&lt;/h3&gt;&lt;p&gt;比如，了解View的绘制过程，了解TouchEvent的分发和拦截过程的细节，才能写出酷炫的UI，要不然，只知道大概的原理的话，你可能要在“无法接收到触摸事件”或者“滑动事件和点击事件冲突”的这些问题上折腾半天。&lt;/p&gt;
&lt;p&gt;又比如，如果哪里出现异常，你能快速定位到源码抛异常类的地方，就能快速解决BUG，对症下药，一招撂倒，有些时候，修复BUG的时间不是用在解决问题上，而是用在定位问题上。&lt;/p&gt;
&lt;p&gt;这里有必要提一下，当Logcat把异常的栈信息打印出来的时候，有些异常出现的原因并不真的是Logcat的信息里描述的原因，因为Logcat里的异常的信息也只是由系统源码打印出来的，而这些源码大多时候只是普通的Java代码，和你自己写的没什么区别，如果源码抛出异常的代码的逻辑不够严谨的话，那实际的异常和Logcat里描述的异常可能对不上。比如之前搞动态加载的时候，在使用LayoutInflator渲染一个外部的XML布局时，抛了一个“Class not found”的异常，我要渲染的类可是LinearLayout啊，怎么可能没有！定位到源码里才发现，这里只要是类渲染失败就会抛这个异常，再定位到具体抛异常的地方，发现实际是Dimens资源找不到，困扰半年的问题立刻解决。&lt;/p&gt;
&lt;h3 id=&quot;其二，能够理解Android设计者的意图。&quot;&gt;&lt;a href=&quot;#其二，能够理解Android设计者的意图。&quot; class=&quot;headerlink&quot; title=&quot;其二，能够理解Android设计者的意图。&quot;&gt;&lt;/a&gt;其二，能够理解Android设计者的意图。&lt;/h3&gt;&lt;p&gt;这个描述可能不好，比如说，许多人都觉得Android开发其实就是Java开发，通过阅读Context类的设计，你能够理解Google是如何在Java的基础上加上Android的特性的，你能够理解Context被叫做“环境”的原因。此外，阅读Activity/Service的源码，你能理解到四大组件类明明就是普通的JAVA类，为什么他们就是组件而别的类就不是组件。阅读Handler/Message/Looper的源码，你还能理解到Handler的精髓，数据驱动比事件驱动更适合用于设计需要经常改动的框架。阅读源码，你能知道Android是怎么管理Window以及向控制View的触摸事件的，你能知道基本上所有的res资源都有等价的Java代码的实现方式，你还能知道Dalvik是怎么无缝向ART过度的，在看通的那一瞬间，保证你觉得“水可载舟，亦可赛艇”！&lt;/p&gt;
&lt;h3 id=&quot;其三，能够学习优秀开源项目的代码风格和设计理念&quot;&gt;&lt;a href=&quot;#其三，能够学习优秀开源项目的代码风格和设计理念&quot; class=&quot;headerlink&quot; title=&quot;其三，能够学习优秀开源项目的代码风格和设计理念&quot;&gt;&lt;/a&gt;其三，能够学习优秀开源项目的代码风格和设计理念&lt;/h3&gt;&lt;p&gt;这也是最重要的，看多了源码之后，你会发现所谓的源码也不过是普通的的Java代码，在不知不觉中受到这些优秀设计思想的影响。相信许多人在看 &lt;strong&gt;Volley&lt;/strong&gt; 源码此前，对异步任务控制的想法基本就是毫无想法，看完之后简直是醍醐灌顶，原来代码也能写得这么有魅力，再看看自己之前写的异步任务，“new Thread().start”…，简直是“too young, sometime naive”有没有。&lt;/p&gt;
&lt;p&gt;看了越来越多Android的源码，自己的写应用的时候，也就能写出更加“Best Performance”的代码，见识了越来越多的开源项目，自己也能够更容易找到最符合自己应用的框架和技术方案，学习了越来越多的优秀的代码风格，自己也就更能写出漂亮以及容易扩展的代码。&lt;/p&gt;
&lt;p&gt;或许对许多做Android开发来说，平时的工作就是按照设计的图写个布局，再解析后台的数据，下班了把测试用的安卓机扔进抽屉拿出自己的苹果手机…… 但有时候花点时间看看源码，或许会觉得设计代码还是挺有意思的，特别是，当你花了两天的时间构思代码，再花两天的时间写代码，这时你可能觉得你还有许多代码要写，但是突然发现只要把你写好的接口衔接一下就都完成了，而且写了两天的代码居然一次编译通过！更甚，产品突然改了个需求，你在抱怨了一顿后发现只要花10分钟把原来的接口换个实现就搞定了，这或许是程序员工作中为数不多的乐趣吧。&lt;/p&gt;
&lt;p&gt;最后，我想说的是，每个人对技术的追求不一样，有的人总是恨不得多知道一点，有的只需要日复一日地重复类似的码代码工作就足够了。所以，“需不需要阅读源码”就是一个伪命题，对任何人来说答案都不太一样。不过，既然Android相比隔壁iOS最大的优势在于开源，如果你还在犹豫要不要阅读源码，我建议有时间还是稍微看看吧，万一就打开新世界的大门呢？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/16-2-8/20986738.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;或许对于许多Android开发者来说，所谓的Android工程师的工作“不过就是用XML实现设计师的美术图，用JSON解析服务器的数据，再把数据显示到界面上”就好了，源码什么的，看也好不看也罢，反正应用层的开发用不上，再加上现在优秀的轮子越来越多，拿来主义泛滥，能用就是，反正老板也不关心是不是你自己写的，用我现在老大的话来说，阅读源码似乎只是一种“锦上添花”的事，有自然好，没有也罢。&lt;/p&gt;
&lt;p&gt;那么，作为Android开发者的自我修养，到底有没有必要阅读AOSP以及其他开源项目的源码呢？&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="源码" scheme="http://kaedea.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CLASSLOADER的工作机制</title>
    <link href="http://kaedea.com/2016/02/07/android-dynamical-loading-02-classloader/"/>
    <id>http://kaedea.com/2016/02/07/android-dynamical-loading-02-classloader/</id>
    <published>2016-02-06T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;早期使用过Eclipse等Java编写的软件的同学可能比较熟悉，Eclipse可以加载许多第三方的插件（或者叫扩展），这就是动态加载。这些插件大多是一些Jar包，而使用插件其实就是动态加载Jar包里的Class进行工作。这其实非常好理解，Java代码都是写在Class里面的，程序运行在虚拟机上时，虚拟机需要把需要的Class加载进来才能创建实例对象并工作，而完成这一个加载工作的角色就是ClassLoader。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://github.com/kaedea&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaedea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;项目：&lt;a href=&quot;https://github.com/kaedea/android-dynamical-loading&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-dynamical-loading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类加载器ClassLoader&quot;&gt;&lt;a href=&quot;#类加载器ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;类加载器ClassLoader&quot;&gt;&lt;/a&gt;类加载器ClassLoader&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;对于Java程序来说，编写程序就是编写类，运行程序也就是运行类（编译得到的&lt;code&gt;class文件&lt;/code&gt;），其中起到关键作用的就是类加载器ClassLoader。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android的Dalvik/ART虚拟机如同标准JAVA的JVM虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。因此，我们可以利用这一点，在程序运行时手动加载Class，从而达到代码动态加载可执行文件的目的。Android的Dalvik/ART虚拟机虽然与标准Java的JVM虚拟机不一样，ClassLoader具体的加载细节不一样，但是工作机制是类似的，也就是说在Android中同样可以采用类似的动态加载插件的功能，只是在Android应用中动态加载一个插件的工作要比Eclipse加载一个插件复杂许多（这点后面在解释说明）。&lt;/p&gt;
&lt;h2 id=&quot;有几个ClassLoader实例？&quot;&gt;&lt;a href=&quot;#有几个ClassLoader实例？&quot; class=&quot;headerlink&quot; title=&quot;有几个ClassLoader实例？&quot;&gt;&lt;/a&gt;有几个ClassLoader实例？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;动态加载的基础是ClassLoader&lt;/strong&gt;，从名字也可以看出，ClassLoader就是专门用来处理类加载工作的，所以这货也叫类加载器，而且一个运行中的APP &lt;strong&gt;不仅只有一个类加载器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实，在Android系统启动的时候会创建一个Boot类型的ClassLoader实例，用于加载一些系统Framework层级需要的类，我们的Android应用里也需要用到一些系统的类，所以APP启动的时候也会把这个Boot类型的ClassLoader传进来。&lt;/p&gt;
&lt;p&gt;此外，APP也有自己的类，这些类保存在APK的dex文件里面，所以APP启动的时候，也会创建一个自己的ClassLoader实例，用于加载自己dex文件中的类。下面我们在项目里验证看看&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ClassLoader classLoader = getClassLoader();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classLoader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Log.i(TAG, &lt;span class=&quot;string&quot;&gt;&quot;[onCreate] classLoader &quot;&lt;/span&gt; + i + &lt;span class=&quot;string&quot;&gt;&quot; : &quot;&lt;/span&gt; + classLoader.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (classLoader.getParent()!=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			classLoader = classLoader.getParent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Log.i(TAG,&lt;span class=&quot;string&quot;&gt;&quot;[onCreate] classLoader &quot;&lt;/span&gt; + i + &lt;span class=&quot;string&quot;&gt;&quot; : &quot;&lt;/span&gt; + classLoader.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输出结果为&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[onCreate] classLoader 1 : dalvik.system.PathClassLoader[DexPathList[[zip file &amp;#34;/data/app/me.kaede.anroidclassloadersample-1/base.apk&amp;#34;],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]&amp;#10;&amp;#10;[onCreate] classLoader 2 : java.lang.BootClassLoader@14af4e32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看见有2个Classloader实例，一个是BootClassLoader（系统启动的时候创建的），另一个是PathClassLoader（应用启动时创建的，用于加载“/data/app/me.kaede.anroidclassloadersample-1/base.apk”里面的类）。由此也可以看出，&lt;strong&gt;一个运行的Android应用至少有2个ClassLoader&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;创建自己ClassLoader实例&quot;&gt;&lt;a href=&quot;#创建自己ClassLoader实例&quot; class=&quot;headerlink&quot; title=&quot;创建自己ClassLoader实例&quot;&gt;&lt;/a&gt;创建自己ClassLoader实例&lt;/h2&gt;&lt;p&gt;动态加载外部的dex文件的时候，我们也可以使用自己创建的ClassLoader实例来加载dex里面的Class，不过ClassLoader的创建方式有点特殊，我们先看看它的构造方法&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * constructor for the BootClassLoader which needs parent to be null.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ClassLoader(ClassLoader parentLoader, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; nullAllowed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (parentLoader == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !nullAllowed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;string&quot;&gt;&quot;parentLoader == null &amp;amp;&amp;amp; !nullAllowed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    parent = parentLoader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个ClassLoader实例的时候，需要使用一个现有的ClassLoader实例作为新创建的实例的Parent。这样一来，一个Android应用，甚至整个Android系统里所有的ClassLoader实例都会被一棵树关联起来，这也是ClassLoader的 &lt;strong&gt;双亲代理模型&lt;/strong&gt;（Parent-Delegation Model）的特点。&lt;/p&gt;
&lt;h2 id=&quot;ClassLoader双亲代理模型加载类的特点和作用&quot;&gt;&lt;a href=&quot;#ClassLoader双亲代理模型加载类的特点和作用&quot; class=&quot;headerlink&quot; title=&quot;ClassLoader双亲代理模型加载类的特点和作用&quot;&gt;&lt;/a&gt;ClassLoader双亲代理模型加载类的特点和作用&lt;/h2&gt;&lt;p&gt;JVM中ClassLoader通过defineClass方法加载jar里面的Class，而Android中这个方法被弃用了。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Deprecated&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt; defineClass(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] classRep, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassFormatError &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span class=&quot;string&quot;&gt;&quot;can&#39;t load this type of class file&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;取而代之的是loadClass方法&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String className) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; loadClass(className, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String className, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; resolve) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class&amp;lt;?&amp;gt; clazz = findLoadedClass(className);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ClassNotFoundException suppressed = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz = parent.loadClass(className, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            suppressed = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                clazz = findClass(className);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.addSuppressed(suppressed);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; clazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;p&gt;从源码中我们也可以看出，loadClass方法在加载一个类的实例的时候，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会先查询当前ClassLoader实例是否加载过此类，有就返回；&lt;/li&gt;
&lt;li&gt;如果没有。查询Parent是否已经加载过此类，如果已经加载过，就直接返回Parent加载的类；&lt;/li&gt;
&lt;li&gt;如果继承路线上的ClassLoader都没有加载，才由Child执行类的加载工作；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样做有个明显的特点，如果一个类被位于树根的ClassLoader加载过，那么在以后整个系统的生命周期内，这个类永远不会被重新加载。&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;首先是共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。&lt;/p&gt;
&lt;p&gt;除此之外还有隔离功能，不同继承路线上的ClassLoader加载的类肯定不是同一个类，这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。这也好理解，一些系统层级的类会在系统初始化的时候被加载，比如java.lang.String，如果在一个应用里面能够简单地用自定义的String类把这个系统的String类给替换掉，那将会有严重的安全问题。&lt;/p&gt;
&lt;h2 id=&quot;使用ClassLoader一些需要注意的问题&quot;&gt;&lt;a href=&quot;#使用ClassLoader一些需要注意的问题&quot; class=&quot;headerlink&quot; title=&quot;使用ClassLoader一些需要注意的问题&quot;&gt;&lt;/a&gt;使用ClassLoader一些需要注意的问题&lt;/h2&gt;&lt;p&gt;我们都知道，我们可以通过动态加载获得新的类，从而升级一些代码逻辑，这里有几个问题要注意一下。&lt;/p&gt;
&lt;p&gt;如果你希望通过动态加载的方式，加载一个新版本的dex文件，使用里面的新类替换原有的旧类，从而修复原有类的BUG，那么你必须保证在加载新类的时候，旧类还没有被加载，因为如果已经加载过旧类，那么ClassLoader会一直优先使用旧类。&lt;/p&gt;
&lt;p&gt;如果旧类总是优先于新类被加载，我们也可以使用一个与加载旧类的ClassLoader没有树的继承关系的另一个ClassLoader来加载新类，因为ClassLoader只会检查其Parent有没有加载过当前要加载的类，如果两个ClassLoader没有继承关系，那么旧类和新类都能被加载。&lt;/p&gt;
&lt;p&gt;不过这样一来又有另一个问题了，在Java中，只有当两个实例的类名、包名以及加载其的ClassLoader都相同，才会被认为是同一种类型。上面分别加载的新类和旧类，虽然包名和类名都完全一样，但是由于加载的ClassLoader不同，所以并不是同一种类型，在实际使用中可能会出现类型不符异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同一个Class = 相同的 ClassName + PackageName + ClassLoader&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上问题在采用动态加载功能的开发中容易出现，请注意。&lt;/p&gt;
&lt;h2 id=&quot;DexClassLoader-和-PathClassLoader&quot;&gt;&lt;a href=&quot;#DexClassLoader-和-PathClassLoader&quot; class=&quot;headerlink&quot; title=&quot;DexClassLoader 和 PathClassLoader&quot;&gt;&lt;/a&gt;DexClassLoader 和 PathClassLoader&lt;/h2&gt;&lt;p&gt;在Android中，ClassLoader是一个抽象类，实际开发过程中，我们一般是使用其具体的子类DexClassLoader、PathClassLoader这些类加载器来加载类的，它们的不同之处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；&lt;/li&gt;
&lt;li&gt;PathClassLoader只能加载系统中已经安装过的apk；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类加载器的初始化&quot;&gt;&lt;a href=&quot;#类加载器的初始化&quot; class=&quot;headerlink&quot; title=&quot;类加载器的初始化&quot;&gt;&lt;/a&gt;类加载器的初始化&lt;/h2&gt;&lt;p&gt;平时开发的时候，使用DexClassLoader就够用了，但是我们不妨挖一下这两者具体细节上的区别。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// DexClassLoader.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, String optimizedDirectory,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String libraryPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(dexPath, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(optimizedDirectory), libraryPath, parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// PathClassLoader.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PathClassLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PathClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(dexPath, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PathClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, String libraryPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(dexPath, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, libraryPath, parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这两者只是简单的对BaseDexClassLoader做了一下封装，具体的实现还是在父类里。不过这里也可以看出，PathClassLoader的optimizedDirectory只能是null，进去BaseDexClassLoader看看这个参数是干什么的&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseDexClassLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String dexPath, File optimizedDirectory,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String libraryPath, ClassLoader parent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.originalPath = dexPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.pathList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DexPathList(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, dexPath, libraryPath, optimizedDirectory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里创建了一个DexPathList实例，进去看看&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DexPathList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ClassLoader definingContext, String dexPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String libraryPath, File optimizedDirectory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Element[] makeDexElements(ArrayList&amp;lt;File&amp;gt; files,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        File optimizedDirectory) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ArrayList&amp;lt;Element&amp;gt; elements = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Element&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (File file : files) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ZipFile zip = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DexFile dex = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String name = file.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (name.endsWith(DEX_SUFFIX)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dex = loadDexFile(file, optimizedDirectory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                || name.endsWith(ZIP_SUFFIX)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            zip = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ZipFile(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((zip != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) || (dex != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            elements.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Element(file, zip, dex));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elements.toArray(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Element[elements.size()]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DexFile &lt;span class=&quot;title&quot;&gt;loadDexFile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File file, File optimizedDirectory)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (optimizedDirectory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DexFile(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String optimizedPath = optimizedPathFor(file, optimizedDirectory);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; DexFile.loadDex(file.getPath(), optimizedPath, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Converts a dex/jar file path and an output directory to an&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * output file path for an associated optimized dex file.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;optimizedPathFor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File path,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        File optimizedDirectory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String fileName = path.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!fileName.endsWith(DEX_SUFFIX)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; lastDot = fileName.lastIndexOf(&lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lastDot &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fileName += DEX_SUFFIX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            StringBuilder sb = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuilder(lastDot + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sb.append(fileName, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, lastDot);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sb.append(DEX_SUFFIX);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fileName = sb.toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    File result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(optimizedDirectory, fileName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result.getPath();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到这里我们明白了，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile&lt;br&gt;对象。&lt;/p&gt;
&lt;p&gt;optimizedDirectory必须是一个内部存储路径，还记得我们之前说过的，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。&lt;/p&gt;
&lt;h2 id=&quot;加载类的过程&quot;&gt;&lt;a href=&quot;#加载类的过程&quot; class=&quot;headerlink&quot; title=&quot;加载类的过程&quot;&gt;&lt;/a&gt;加载类的过程&lt;/h2&gt;&lt;p&gt;上面还只是创建了类加载器的实例，其中创建了一个DexFile实例，用来保存dex文件，我们猜想这个实例就是用来加载类的。&lt;/p&gt;
&lt;p&gt;Android中，ClassLoader用loadClass方法来加载我们需要的类&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String className) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; loadClass(className, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String className, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; resolve) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Class&amp;lt;?&amp;gt; clazz = findLoadedClass(className);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ClassNotFoundException suppressed = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              clazz = parent.loadClass(className, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              suppressed = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  clazz = findClass(className);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  e.addSuppressed(suppressed);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; clazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;loadClass方法调用了findClass方法，而BaseDexClassLoader重载了这个方法，得到BaseDexClassLoader看看&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ClassNotFoundException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Class clazz = pathList.findClass(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassNotFoundException(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; clazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果还是调用了DexPathList的findClass&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class &lt;span class=&quot;title&quot;&gt;findClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Element element : dexElements) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DexFile dex = element.dexFile;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (dex != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class clazz = dex.loadClassBinaryName(name, definingContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (clazz != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; clazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里遍历了之前所有的DexFile实例，其实也就是遍历了所有加载过的dex文件，再调用loadClassBinaryName方法一个个尝试能不能加载想要的类，真是简单粗暴&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class &lt;span class=&quot;title&quot;&gt;loadClassBinaryName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, ClassLoader loader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; defineClass(name, loader, mCookie);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Class &lt;span class=&quot;title&quot;&gt;defineClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name, ClassLoader loader, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cookie)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到这里想必大家都明白了，loadClassBinaryName中调用了Native方法defineClass加载类。&lt;/p&gt;
&lt;p&gt;至此，ClassLoader的创建和加载类的过程的完成了。有趣的是，标准JVM中，ClassLoader是用defineClass加载类的，而Android中defineClass被弃用了，改用了loadClass方法，而且加载类的过程也挪到了DexFile中，在DexFile中加载类的具体方法也叫defineClass，不知道是Google故意写成这样的还是巧合。&lt;/p&gt;
&lt;h2 id=&quot;自定义ClassLoader&quot;&gt;&lt;a href=&quot;#自定义ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;自定义ClassLoader&quot;&gt;&lt;/a&gt;自定义ClassLoader&lt;/h2&gt;&lt;p&gt;平时进行动态加载开发的时候，使用DexClassLoader就够了。但我们也可以创建自己的类去继承ClassLoader，需要注意的是loadClass方法并不是final类型的，所以我们可以重载loadClass方法并改写类的加载逻辑。&lt;/p&gt;
&lt;p&gt;通过前面我们分析知道，ClassLoader双亲代理的实现很大一部分就是在loadClass方法里，我们可以通过重写loadClass方法避开双亲代理的框架，这样一来就可以在重新加载已经加载过的类，也可以在加载类的时候注入一些代码。这是一种Hack的开发方式，采用这种开发方式的程序稳定性可能比较差，但是却可以实现一些“黑科技”的功能。&lt;/p&gt;
&lt;h2 id=&quot;Android程序比起一般Java程序在使用动态加载时麻烦在哪里&quot;&gt;&lt;a href=&quot;#Android程序比起一般Java程序在使用动态加载时麻烦在哪里&quot; class=&quot;headerlink&quot; title=&quot;Android程序比起一般Java程序在使用动态加载时麻烦在哪里&quot;&gt;&lt;/a&gt;Android程序比起一般Java程序在使用动态加载时麻烦在哪里&lt;/h2&gt;&lt;p&gt;通过上面的分析，我们知道使用ClassLoader动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的Java程序，在Android程序中使用动态加载主要有两个麻烦的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Android中许多组件类（如Activity、Service等）是需要在Manifest文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作；&lt;/li&gt;
&lt;li&gt;Res资源是Android开发中经常用到的，而Android是把这些资源用对应的R.id注册好，运行时通过这些ID从Resource实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到R.id的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源ID根本和现有的Resource实例中保存的资源ID对不上；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说到底，抛开虚拟机的差别不说，&lt;strong&gt;一个Android程序和标准的Java程序最大的区别就在于他们的上下文环境（Context）不同&lt;/strong&gt;。Android中，这个环境可以给程序提供组件需要用到的功能，也可以提供一些主题、Res等资源，其实上面说到的两个问题都可以统一说是这个环境的问题，而现在的各种Android动态加载框架中，核心要解决的东西也正是“如何给外部的新类提供上下文环境”的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;早期使用过Eclipse等Java编写的软件的同学可能比较熟悉，Eclipse可以加载许多第三方的插件（或者叫扩展），这就是动态加载。这些插件大多是一些Jar包，而使用插件其实就是动态加载Jar包里的Class进行工作。这其实非常好理解，Java代码都是写在Class里面的，程序运行在虚拟机上时，虚拟机需要把需要的Class加载进来才能创建实例对象并工作，而完成这一个加载工作的角色就是ClassLoader。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ANDROID动态加载简单易懂的介绍方式</title>
    <link href="http://kaedea.com/2016/02/06/android-dynamical-loading-01-introduction/"/>
    <id>http://kaedea.com/2016/02/06/android-dynamical-loading-01-introduction/</id>
    <published>2016-02-05T16:00:00.000Z</published>
    <updated>2016-06-13T08:41:55.000Z</updated>
    
    <content type="html">&lt;p&gt;我们很早开始就在Android项目中采用了动态加载技术，主要目的是为了达到让用户不用重新安装APK就能升级应用的功能（特别是 SDK项目），这样一来不但可以大大提高应用新版本的覆盖率，也减少了服务器对旧版本接口兼容的压力，同时如果也可以快速修复一些线上的BUG。&lt;/p&gt;
&lt;p&gt;这种技术并不是常规的Android开发方式，早期并没有完善的解决方案。从“不明觉厉”到稳定投入生产，一直以来我总想对此编写一些文档，这也是这篇日志的由来，没想到前前后后竟然拖沓着编辑了一年多，所以日志里有的地方思路可能有点衔接得不是很好，如果有修正建议请直接回复。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Author：&lt;a href=&quot;https://github.com/kaedea&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kaedea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub：&lt;a href=&quot;https://github.com/kaedea/android-dynamical-loading&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-dynamical-loading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h2&gt;&lt;p&gt;通过服务器配置一些参数，Android APP获取这些参数再做出相应的逻辑，这是常有的事情。&lt;/p&gt;
&lt;p&gt;比如现在大部分APP都有一个启动页面，如果到了一些重要的节日，APP的服务器会配置一些与时节相关的图片，APP启动时候再把原有的启动图换成这些新的图片，这样就能提高用户的体验了。&lt;/p&gt;
&lt;p&gt;再则，早期个人开发者在安卓市场上发布应用的时候，如果应用里包含有广告，那么有可能会审核不通过。那么就通过在服务器配置一个开关，审核应用的时候先把开关关闭，这样应用就不会显示广告了；安卓市场审核通过后，再把服务器的广告开关给打开，以这样的手段规避市场的审核。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;道高一尺魔高一丈&lt;/strong&gt;。安卓市场开始扫描APK里面的Manifest甚至dex文件，查看开发者的APK包里是否有广告的代码，如果有就有可能审核不通过。&lt;/p&gt;
&lt;p&gt;通过服务器怕配置开关参数的方法行不通了，开发者们开始想，“既然这样，能不能先不要在APK写广告的代码，在用户运行APP的时候，再从服务器下载广告的代码，运行，再现实广告呢？”。答案是肯定的，这就是动态加载：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在程序运行的时候，加载一些程序自身原本不存在的可执行文件并运行这些文件里的代码逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来就像是应用从服务器下载了一些代码，然后再执行这些代码！&lt;/p&gt;
&lt;h2 id=&quot;传统PC软件中的动态加载技术&quot;&gt;&lt;a href=&quot;#传统PC软件中的动态加载技术&quot; class=&quot;headerlink&quot; title=&quot;传统PC软件中的动态加载技术&quot;&gt;&lt;/a&gt;传统PC软件中的动态加载技术&lt;/h2&gt;&lt;p&gt;动态加载技术在PC软件领域广泛使用，比如输入法的截图功能。刚刚安装好的输入法软件可能没有截图功能，当你第一次使用的时候，输入法会先从服务器下载并安装截图软件，然后再执行截图功能。&lt;/p&gt;
&lt;p&gt;此外，许多的PC软件的安装目录里面都有大量的DLL文件（Dynamic Link Library）,PC软件则是通过调用这些DLL里面的代码执行特定的功能的，这就是一种动态加载技术。&lt;/p&gt;
&lt;p&gt;熟悉Java的同学应该比较清楚，Java的可执行文件是Jar，运行在虚拟机上JVM上，虚拟机通过ClassLoader加载Jar文件并执行里面的代码。所以Java程序也可以通过动态调用Jar文件达到动态加载的目的。&lt;/p&gt;
&lt;h2 id=&quot;Android应用的动态加载技术&quot;&gt;&lt;a href=&quot;#Android应用的动态加载技术&quot; class=&quot;headerlink&quot; title=&quot;Android应用的动态加载技术&quot;&gt;&lt;/a&gt;Android应用的动态加载技术&lt;/h2&gt;&lt;p&gt;Android应用类似于Java程序，虚拟机换成了Dalvik/ART，而Jar换成了Dex。在Android APP运行的时候，我们是不是也可以通过下载新的应用，或者通过调用外部的Dex文件来实现动态加载呢？&lt;/p&gt;
&lt;p&gt;然而在Android上实现起来可没那么容易，如果下载一个新的APK下来，不安装这个APK的话可不能运行。如果让用户手动安装完这个APK再启动，那可不像是动态加载，纯粹就是用户安装了一个新的应用，然后再启动这个新的应用（这种做法也叫做“静默安装”）。&lt;/p&gt;
&lt;p&gt;动态调用外部的Dex文件则是完全没有问题的。在APK文件中往往有一个或者多个Dex文件，我们写的每一句代码都会被编译到这些文件里面，Android应用运行的时候就是通过执行这些Dex文件完成应用的功能的。虽然一个APK一旦构建出来，我们是无法更换里面的Dex文件的，但是我们可以通过加载外部的Dex文件来实现动态加载，这个外部文件可以放在外部存储，或者从网络下载。&lt;/p&gt;
&lt;h2 id=&quot;动态加载的定义&quot;&gt;&lt;a href=&quot;#动态加载的定义&quot; class=&quot;headerlink&quot; title=&quot;动态加载的定义&quot;&gt;&lt;/a&gt;动态加载的定义&lt;/h2&gt;&lt;p&gt;开始正题之前，在这里可以先给动态加载技术做一个简单的定义。真正的动态加载应该是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用在运行的时候通过加载一些&lt;strong&gt;本地不存在&lt;/strong&gt;的可执行文件实现一些特定的功能;&lt;/li&gt;
&lt;li&gt;这些可执行文件是&lt;strong&gt;可以替换&lt;/strong&gt;的;&lt;/li&gt;
&lt;li&gt;更换静态资源（比如换启动图、换主题、或者用服务器参数开关控制广告的隐藏现实等）&lt;strong&gt;不属于&lt;/strong&gt; 动态加载;&lt;/li&gt;
&lt;li&gt;Android中动态加载的核心思想是动态调用外部的 &lt;strong&gt;dex文件&lt;/strong&gt;，极端的情况下，Android APK自身带有的Dex文件只是一个程序的入口（或者说空壳），所有的功能都通过从服务器下载最新的Dex文件完成;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Android动态加载的类型&quot;&gt;&lt;a href=&quot;#Android动态加载的类型&quot; class=&quot;headerlink&quot; title=&quot;Android动态加载的类型&quot;&gt;&lt;/a&gt;Android动态加载的类型&lt;/h2&gt;&lt;p&gt;Android项目中，动态加载技术按照加载的可执行文件的不同大致可以分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态加载&lt;code&gt;so库&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;动态加载&lt;code&gt;dex/jar/apk文件&lt;/code&gt;（现在动态加载普遍说的是这种）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其一，Android中NDK中其实就使用了动态加载，动态加载&lt;code&gt;.so库&lt;/code&gt;并通过JNI调用其封装好的方法。后者一般是由&lt;code&gt;C/C++&lt;/code&gt;编译而成，运行在Native层，效率会比执行在虚拟机层的Java代码高很多，所以Android中经常通过动态加载&lt;code&gt;.so库&lt;/code&gt;来完成一些对性能比较有需求的工作（比如T9搜索、或者Bitmap的解码、图片高斯模糊处理等）。此外，由于&lt;code&gt;so库&lt;/code&gt;是由&lt;code&gt;C/C++&lt;/code&gt;编译而来的，只能被反编译成汇编代码，相比中&lt;code&gt;dex文件&lt;/code&gt;反编译得到的Smali代码更难被破解，因此&lt;code&gt;so库&lt;/code&gt;也可以被用于安全领域。&lt;strong&gt;这里为后面要讲的内容提前说明一下，一般情况下我们是把&lt;code&gt;so库&lt;/code&gt;一并打包在APK内部的，但是&lt;code&gt;so库&lt;/code&gt;其实也是可以从外部存储文件加载的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其二，“基于ClassLoader的动态加载&lt;code&gt;dex/jar/apk文件&lt;/code&gt;”，就是我们上面提到的“在Android中动态加载由Java代码编译而来的&lt;code&gt;dex&lt;/code&gt;包并执行其中的代码逻辑”，&lt;strong&gt;这是常规Android开发比较少用到的一种技术&lt;/strong&gt;，目前网络上大多文章说到的动态加载指的就是这种（后面我们谈到“动态加载”如果没有特别指定，均默认是这种）。&lt;/p&gt;
&lt;p&gt;Android项目中，所有Java代码都会被编译成&lt;code&gt;dex文件&lt;/code&gt;，Android应用运行时，就是通过执行&lt;code&gt;dex文件&lt;/code&gt;里的业务代码逻辑来工作的。使用动态加载技术可以在Android应用运行时加载外部的&lt;code&gt;dex文件&lt;/code&gt;，而通过网络下载新的&lt;code&gt;dex文件&lt;/code&gt;并替换原有的&lt;code&gt;dex文件&lt;/code&gt;就可以达到不安装新APK文件就升级应用（改变代码逻辑）的目的。同时，使用动态加载技术，一般来说会使得Android开发工作变得更加复杂，这中开发方式不是官方推荐的，不是目前主流的Android开发方式，&lt;strong&gt;Github&lt;/strong&gt; 和 &lt;strong&gt;StackOverflow&lt;/strong&gt; 上面外国的开发者也对此不是很感兴趣，外国相关的教程更是少得可怜，目前只有在大天朝才有比较深入的研究和应用，特别是一些SDK组件项目和 &lt;strong&gt;BAT家族&lt;/strong&gt; 的项目上，Github上的相关开源项目基本是国人在维护，偶尔有几个外国人请求更新英文文档。&lt;/p&gt;
&lt;h2 id=&quot;Android动态加载的大致过程&quot;&gt;&lt;a href=&quot;#Android动态加载的大致过程&quot; class=&quot;headerlink&quot; title=&quot;Android动态加载的大致过程&quot;&gt;&lt;/a&gt;Android动态加载的大致过程&lt;/h2&gt;&lt;p&gt;无论上面的哪种动态加载，其实基本原理都是在程序运行时加载一些外部的可执行的文件，然后调用这些文件的某个方法执行业务逻辑。需要说明的是，因为文件是可执行的（so库或者dex包，也就是一种动态链接库），出于安全问题，Android并不允许直接加载手机外部存储这类&lt;code&gt;noexec&lt;/code&gt;（不可执行）存储路径上的可执行文件。&lt;/p&gt;
&lt;p&gt;对于这些外部的可执行文件，在Android应用中调用它们前，都要先把他们拷贝到&lt;code&gt;data/packagename/&lt;/code&gt;内部储存文件路径，确保库不会被第三方应用恶意修改或拦截，然后再将他们加载到当前的运行环境并调用需要的方法执行相应的逻辑，从而实现动态调用。&lt;/p&gt;
&lt;p&gt;动态加载的大致过程就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;把可执行文件（.so/dex/jar/apk）拷贝到应用APP内部存储；&lt;/li&gt;
&lt;li&gt;加载可执行文件；&lt;/li&gt;
&lt;li&gt;调用具体的方法执行业务逻辑；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下分别对这两种动态加载的实现方式做比较深入的介绍。&lt;/p&gt;
&lt;h2 id=&quot;动态加载-so库&quot;&gt;&lt;a href=&quot;#动态加载-so库&quot; class=&quot;headerlink&quot; title=&quot;动态加载 so库&quot;&gt;&lt;/a&gt;动态加载 &lt;strong&gt;so库&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;动态加载&lt;code&gt;so库&lt;/code&gt;应该就是Android最早期的动态加载了，不过&lt;code&gt;so库&lt;/code&gt;不仅可以存放在APK文件内部，还可以存放在外部存储。Android开发中，更换&lt;code&gt;so库&lt;/code&gt;的情形并不多，但是可以通过把&lt;code&gt;so库&lt;/code&gt;挪动到APK外部，减少APK的体积，毕竟许多&lt;code&gt;so库&lt;/code&gt;文件的体积可是非常大的。&lt;/p&gt;
&lt;p&gt;详细的应用方式请参考后续日志 &lt;a href=&quot;http://segmentfault.com/a/1190000004062899&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载补充 加载SD卡的SO库&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;动态加载-dex-jar-apk文件&quot;&gt;&lt;a href=&quot;#动态加载-dex-jar-apk文件&quot; class=&quot;headerlink&quot; title=&quot;动态加载 dex/jar/apk文件&quot;&gt;&lt;/a&gt;动态加载 &lt;strong&gt;dex/jar/apk文件&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们经常讲到的那种Android动态加载技术就是这种，后面我们谈到“动态加载”如果没有特别指定，均默认是这个。&lt;/p&gt;
&lt;h3 id=&quot;基础知识：类加载器ClassLoader和dex文件&quot;&gt;&lt;a href=&quot;#基础知识：类加载器ClassLoader和dex文件&quot; class=&quot;headerlink&quot; title=&quot;基础知识：类加载器ClassLoader和dex文件&quot;&gt;&lt;/a&gt;基础知识：类加载器ClassLoader和dex文件&lt;/h3&gt;&lt;p&gt;动态加载dex/jar/apk文件的基础是类加载器ClassLoader，它的包路径是&lt;code&gt;java.lang&lt;/code&gt;，由此可见其重要性，虚拟机就是通过类加载器加载其需要用的Class，这是Java程序运行的基础。&lt;/p&gt;
&lt;p&gt;关于类加载器ClassLoader的工作机制，请参考 &lt;a href=&quot;http://segmentfault.com/a/1190000004062880&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载基础 ClassLoader的工作机制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在网上有多种基于ClassLoader的Android动态加载的开源项目，大部分核心思想都殊途同归，按照复杂程度以及具体实现的框架，大致可以分为以下三种形式，或者说模式 &lt;a id=&quot;a1&quot; href=&quot;#f1&quot;&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;简单的动态加载模式&quot;&gt;&lt;a href=&quot;#简单的动态加载模式&quot; class=&quot;headerlink&quot; title=&quot;简单的动态加载模式&quot;&gt;&lt;/a&gt;简单的动态加载模式&lt;/h3&gt;&lt;p&gt;理解ClassLoader的工作机制后，我们知道了Android应用在运行时使用ClassLoader动态加载外部的dex文件非常简单，不用覆盖安装新的APK，就可以更改APP的代码逻辑。但是Android却很难使用插件APK里的res资源，这意味着无法使用新的XML布局等资源，同时由于无法更改本地的Manifest清单文件，所以无法启动新的Activity等组件。&lt;/p&gt;
&lt;p&gt;不过可以先把要用到的全部res资源都放到主APK里面，同时把所有需要的Activity先全部写进Manifest里，只通过动态加载更新代码，不更新res资源，如果需要改动UI界面，可以通过使用纯Java代码创建布局的方式绕开XML布局。同时也可以使用Fragment代替Activity，这样可以最大限度得避开“无法注册新组件的限制”。&lt;/p&gt;
&lt;p&gt;某种程度上，简单的动态加载功能已经能满足部分业务需求了，特别是一些早期的Android项目，那时候Android的技术还不是很成熟，而且早期的Android设备更是有大量的兼容性问题（做过Android1.6兼容的同学可能深有体会），只有这种简单的加载方式才能稳定运行。这种模式的框架比较适用一些UI变化比较少的项目，比如游戏SDK，基本就只有登陆、注册界面，而且基本不会变动，更新的往往只有代码逻辑。&lt;/p&gt;
&lt;p&gt;详细的应用方式请参考后续日志 &lt;a href=&quot;http://segmentfault.com/a/1190000004062952&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载入门 简单加载模式&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;代理Activity模式&quot;&gt;&lt;a href=&quot;#代理Activity模式&quot; class=&quot;headerlink&quot; title=&quot;代理Activity模式&quot;&gt;&lt;/a&gt;代理Activity模式&lt;/h3&gt;&lt;p&gt;简单加载模式还是不够用，所以代理模式出现了。从这个阶段开始就稍微有点“黑科技”的味道了，比如我们可以通过动态加载，让现在的Android应用启动一些“新”的Activity，甚至不用安装就启动一个“新”的APK。宿主APK&lt;a id=&quot;a2&quot; href=&quot;#f2&quot;&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/a&gt;需要先注册一个空壳的Activity用于代理执行插件APK的Activity的生命周期。&lt;/p&gt;
&lt;p&gt;主要有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;宿主APK可以启动未安装的插件APK；&lt;/li&gt;
&lt;li&gt;插件APK也可以作为一个普通APK安装并且启动；&lt;/li&gt;
&lt;li&gt;插件APK可以调用宿主APK里的一些功能；&lt;/li&gt;
&lt;li&gt;宿主APK和插件APK都要接入一套指定的接口框架才能实现以上功能；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同时也主要有一下几点限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要在Manifest注册的功能都无法在插件实现，比如应用权限、LaunchMode、静态广播等；&lt;/li&gt;
&lt;li&gt;宿主一个代理用的Activity难以满足插件一些特殊的Activity的需求，插件Activity的开发受限于代理Activity；&lt;/li&gt;
&lt;li&gt;宿主项目和插件项目的开发都要接入共同的框架，大多时候，插件需要依附宿主才能运行，无法独立运行；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细的应用方式请参考后续日志 &lt;a href=&quot;http://segmentfault.com/a/1190000004062972&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载进阶 代理Activity模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;代理Activity模式的核心在于“使用宿主的一个代理Activity为插件所有的Activity提供组件工作需要的环境”，随着代理模式的逐渐成熟，现在还出现了“使用Hack手段给插件的Activity注入环境”的模式，这里暂时不展开，以后会继续分析。&lt;/p&gt;
&lt;p&gt;我们目前有投入到生产中的开发方式只有简单模式和代理模式，在设计的前期遇到不少兼容性的问题，不过好在Android 4.0以后的机型上就比较少了。&lt;/p&gt;
&lt;h3 id=&quot;动态创建Activity模式&quot;&gt;&lt;a href=&quot;#动态创建Activity模式&quot; class=&quot;headerlink&quot; title=&quot;动态创建Activity模式&quot;&gt;&lt;/a&gt;动态创建Activity模式&lt;/h3&gt;&lt;p&gt;天了噜，到了这个阶段就真的是“黑科技”的领域了，从而使其可以正常运行。可以试想“从网络下载一个Flappy Bird的APK，不用安装就直接运行游戏”，或者“同时运行两个甚至多个微信”。&lt;/p&gt;
&lt;p&gt;动态创建Activity模式的核心是“运行时字节码操作”，现在宿主注册一个不存在的Activity，启动插件的某个Activity时都把想要启动的Activity替换成前面注册的Activity，从而是后者能正常启动。&lt;/p&gt;
&lt;p&gt;这个模式有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主APK可以启动一个未安装的插件APK；&lt;/li&gt;
&lt;li&gt;插件APK可以是任意第三方APK，无需接入指定的接口，理所当然也可以独立运行；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细的应用方式请参考后续日志 &lt;a href=&quot;http://segmentfault.com/a/1190000004077469&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载黑科技 动态创建Activity模式&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么我们要使用动态加载技术&quot;&gt;&lt;a href=&quot;#为什么我们要使用动态加载技术&quot; class=&quot;headerlink&quot; title=&quot;为什么我们要使用动态加载技术&quot;&gt;&lt;/a&gt;为什么我们要使用动态加载技术&lt;/h2&gt;&lt;p&gt;说实话，作为开发我们也不想使用的，这是产品要求的！（警察蜀黍就是他，他只问我能不能实现，并木有问我实现起来难不难……好吧我们知道他们也没得选。）&lt;/p&gt;
&lt;p&gt;Android开发中，最先使用动态加载技术的应该是SDK项目吧。现在网上有一大堆Android SDK项目，比如Google的Goole Play Service，向开发者提供支付、地图等功能，又比如一些Android游戏市场的SDK，用于向游戏开发者提供账号和支付功能。和普通Android应用一样，这些SDK项目也是要升级的，比如现在别人的Android应用里使用了我们的SDK1.0版本，然后发布到安卓市场上去。现在我们发现SDK1.0有一些紧急的BUG，所以升级了一个SDK1.1版本，没办法，只能让人家重新接入1.1版本再发布到市场。万一我们有SDK1.2、1.3等版本呢，本来让人家每个版本都重新接入也无可厚非，不过产品可关心体验啊，他就会问咯，“虽然我不懂技术，但是我想知道有没有办法，能让人家只接入一次我们的SDK，以后我们发布新的SDK版本的时候他们的项目也能跟着自动升级？”，答曰，“有，使用动态加载的技术能办到，只不过（开发工作量会剧增…）”，“那就用吧，我们要把产品的体验做到极致”。&lt;/p&gt;
&lt;p&gt;好吧，我并没有黑产品的意思，现在团队的产品也不错，不过与上面类似的对话确实发生在我以前的项目里。这里提出来只是为了强调一下Android项目中采用动态加载技术的 &lt;strong&gt;作用&lt;/strong&gt; 以及由此带来的 &lt;strong&gt;代价&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;作用与代价&quot;&gt;&lt;a href=&quot;#作用与代价&quot; class=&quot;headerlink&quot; title=&quot;作用与代价&quot;&gt;&lt;/a&gt;作用与代价&lt;/h2&gt;&lt;p&gt;凡事都有两面性，特别是这种 &lt;strong&gt;非官方支持&lt;/strong&gt; 的 &lt;strong&gt;非常规&lt;/strong&gt; 开发方式，在采用前一定要权衡清楚其作用与代价。如果决定了要采用动态加载技术，个人推荐可以现在实际项目的一些比较独立的模块使用这种框架，把遇到的一些问题解决之后，再慢慢引进到项目的核心模块；如果遇到了一些无法跨越的问题，要有能够迅速投入生产的替代方案。&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;规避APK覆盖安装的升级过程，提高用户体验，顺便能 &lt;strong&gt;规避&lt;/strong&gt; 一些安卓市场的限制；&lt;/li&gt;
&lt;li&gt;动态修复应用的一些 &lt;strong&gt;紧急BUG&lt;/strong&gt;，做好最后一道保障；&lt;/li&gt;
&lt;li&gt;当应用体积太庞大的时候，可以把一些模块通过动态加载以插件的形式分割出去，这样可以减少主项目的体积，&lt;strong&gt;提高项目的编译速度&lt;/strong&gt;，也能让主项目和插件项目并行开发；&lt;/li&gt;
&lt;li&gt;插件模块可以用懒加载的方式在需要的时候才初始化，从而 &lt;strong&gt;提高应用的启动速度&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;从项目管理上来看，分割插件模块的方式做到了 &lt;strong&gt;项目级别的代码分离&lt;/strong&gt;，大大降低模块之间的耦合度，同一个项目能够分割出不同模块在多个开发团队之间 &lt;strong&gt;并行开发&lt;/strong&gt;，如果出现BUG也容易定位问题；&lt;/li&gt;
&lt;li&gt;在Android应用上 &lt;strong&gt;推广&lt;/strong&gt; 其他应用的时候，可以使用动态加载技术让用户优先体验新应用的功能，而不用下载并安装全新的APK；&lt;/li&gt;
&lt;li&gt;减少主项目DEX的方法数，&lt;strong&gt;65535问题&lt;/strong&gt; 彻底成为历史（虽然现在在Android Studio中很容易开启MultiDex，这个问题也不难解决）；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;代价&quot;&gt;&lt;a href=&quot;#代价&quot; class=&quot;headerlink&quot; title=&quot;代价&quot;&gt;&lt;/a&gt;代价&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发方式可能变得比较诡异、繁琐，与常规开发方式不同；&lt;/li&gt;
&lt;li&gt;随着动态加载框架复杂程度的加深，项目的构建过程也变得复杂，有可能要主项目和插件项目分别构建，再整合到一起；&lt;/li&gt;
&lt;li&gt;由于插件项目是独立开发的，当主项目加载插件运行时，插件的运行环境已经完全不同，代码逻辑容易出现BUG，而且在主项目中调试插件十分繁琐；&lt;/li&gt;
&lt;li&gt;非常规的开发方式，有些框架使用反射强行调用了部分Android系统Framework层的代码，部分Android ROM可能已经改动了这些代码，所以有存在兼容性问题的风险，特别是在一些古老Android设备和部分三星的手机上；&lt;/li&gt;
&lt;li&gt;采用动态加载的插件在使用系统资源（特别是Theme）时经常有一些兼容性问题，特别是部分三星的手机；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;其他动态修改代码的技术&quot;&gt;&lt;a href=&quot;#其他动态修改代码的技术&quot; class=&quot;headerlink&quot; title=&quot;其他动态修改代码的技术&quot;&gt;&lt;/a&gt;其他动态修改代码的技术&lt;/h2&gt;&lt;p&gt;上面说到的都是基于ClassLoader的动态加载技术（除了加载SO库外），使用ClassLoader的一个特点就是，如果程序不重新启动，加载过一次的类就无法重新加载。因此，如果使用ClassLoader来动态升级APP或者动态修复BUG，都需要重新启动APP才能生效。&lt;/p&gt;
&lt;p&gt;除了使用ClassLoader外，还可以使用jni hook的方式修改程序的执行代码。前者是在虚拟机上操作的，而后者做的已经是Native层级的工作了，直接修改应用运行时的内存地址，所以使用jni hook的方式时，不用重新应用就能生效。&lt;/p&gt;
&lt;p&gt;目前采用jni hook方案的项目中比较热门的有阿里的dexposed和AndFix，有兴趣的同学可以参考 &lt;a href=&quot;http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;各大热补丁方案分析和比较&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;动态加载开源项目&quot;&gt;&lt;a href=&quot;#动态加载开源项目&quot; class=&quot;headerlink&quot; title=&quot;动态加载开源项目&quot;&gt;&lt;/a&gt;动态加载开源项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bunnyblue/ACDD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ACDD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/singwhatiwanna/dynamic-load-apk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DL dynamic-load-apk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/houkx/android-pluginmgr&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-pluginmgr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/FinalLody/Direct-Load-apk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Direct-Load-apk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Qihoo360/DroidPlugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;360 DroidPlugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CtripMobile/DynamicAPK&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;携程网 DynamicAPK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jasonross/Nuwa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;女娲 Nuwa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/limpoxe/Android-Plugin-Framework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android-Plugin-Framework&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;脚注&quot;&gt;&lt;a href=&quot;#脚注&quot; class=&quot;headerlink&quot; title=&quot;脚注&quot;&gt;&lt;/a&gt;脚注&lt;/h2&gt;&lt;!-- footnotes --&gt;
&lt;footer class=&quot;footnotes&quot;&gt;&lt;br&gt;&lt;a id=&quot;f1&quot; href=&quot;#a1&quot;&gt;[1]&lt;/a&gt; 其实也说不上什么模式，这不过这些动态加载的开发方式都有自己明显的特征，所以姑且用“形式或者模式”来称呼好了。&lt;br&gt;&lt;br&gt;&lt;a id=&quot;f2&quot; href=&quot;#a2&quot;&gt;[2]&lt;/a&gt; 为了方便区分概念，阐述一些术语：&lt;br&gt;宿主：Host，主项目APK、主APK，也就是我们希望采用动态加载技术的主项目；&lt;br&gt;插件：Plugin，可以是dex、jar或者apk文件，从主项目分离开来，我们能通过动态加载加载到主项目里面来的模块，一个主APK可以同时加载多个插件APK；&lt;br&gt;&lt;br&gt;&lt;/footer&gt;



&lt;!-- css --&gt;
&lt;style type=&quot;text/css&quot;&gt;
.footnotes {
    // border-top: 1px solid #ccc;
    font-size: 1.4rem;
    margin-top: -2rem;
    //padding-top: 1.5rem;
}
}
&lt;/style&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们很早开始就在Android项目中采用了动态加载技术，主要目的是为了达到让用户不用重新安装APK就能升级应用的功能（特别是 SDK项目），这样一来不但可以大大提高应用新版本的覆盖率，也减少了服务器对旧版本接口兼容的压力，同时如果也可以快速修复一些线上的BUG。&lt;/p&gt;
&lt;p&gt;这种技术并不是常规的Android开发方式，早期并没有完善的解决方案。从“不明觉厉”到稳定投入生产，一直以来我总想对此编写一些文档，这也是这篇日志的由来，没想到前前后后竟然拖沓着编辑了一年多，所以日志里有的地方思路可能有点衔接得不是很好，如果有修正建议请直接回复。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ANDROID动态加载系列索引</title>
    <link href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index/"/>
    <id>http://kaedea.com/2016/02/05/android-dynamical-loading-00-index/</id>
    <published>2016-02-04T16:00:00.000Z</published>
    <updated>2016-06-26T08:19:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-30/1635252.jpg&quot; alt=&quot;android-dynamical-loading&quot; title=&quot;android-dynamical-loading&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Android开发中采用动态加载技术，可以达到不安装新的APK就升级APP功能的目的，可以用来到达快速发版的目的，也可以用来修复一些紧急BUG。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Author：&lt;a href=&quot;https://github.com/kaedea&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kaedea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub：&lt;a href=&quot;https://github.com/kaedea/android-dynamical-loading&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-dynamical-loading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;动态加载介绍&quot;&gt;&lt;a href=&quot;#动态加载介绍&quot; class=&quot;headerlink&quot; title=&quot;动态加载介绍&quot;&gt;&lt;/a&gt;动态加载介绍&lt;/h2&gt;&lt;p&gt;现在使用得比较广泛的动态加载技术的核心一般都是使用 &lt;strong&gt;ClassLoader&lt;/strong&gt; ，后者能够加载程序外部的类（已编译好的），从而达到升级代码逻辑的目的。虽然动态加载的核心原理比较简单，但是根据功能的复杂程度，实际在Android项目中使用的时候还要涉及许多其他方面的知识，这里分为几个篇幅分别进行介绍。&lt;/p&gt;
&lt;h4 id=&quot;简单易懂的介绍&quot;&gt;&lt;a href=&quot;#简单易懂的介绍&quot; class=&quot;headerlink&quot; title=&quot;简单易懂的介绍&quot;&gt;&lt;/a&gt;简单易懂的介绍&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态加载技术在Android中的使用背景；&lt;/li&gt;
&lt;li&gt;Android的动态的加载大致可以分为“加载SO库”和“加载DEX/JAR/APK”两种；&lt;/li&gt;
&lt;li&gt;动态加载的基础是类加载器ClassLoader；&lt;/li&gt;
&lt;li&gt;使用动态加载的三种模式；&lt;/li&gt;
&lt;li&gt;采用动态加载的作用与代价；&lt;/li&gt;
&lt;li&gt;除了ClassLoader之外的动态修改代码的技术（HotFix）；&lt;/li&gt;
&lt;li&gt;一些动态加载的开源项目；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004062866&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载技术 简单易懂的介绍&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;类加载器ClassLoader的工作机制&quot;&gt;&lt;a href=&quot;#类加载器ClassLoader的工作机制&quot; class=&quot;headerlink&quot; title=&quot;类加载器ClassLoader的工作机制&quot;&gt;&lt;/a&gt;类加载器ClassLoader的工作机制&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载器ClassLoader的创建过程和加载类的过程；&lt;/li&gt;
&lt;li&gt;ClassLoader的双亲代理模式；&lt;/li&gt;
&lt;li&gt;DexClassLoader和PathClassLoader之间的区别；&lt;/li&gt;
&lt;li&gt;使用ClassLoader加载外部类需要注意的一些问题；&lt;/li&gt;
&lt;li&gt;自定义ClassLoader（Hack开发）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文章地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004062880&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载基础 ClassLoader的工作机制&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;加载SD卡的SO库&quot;&gt;&lt;a href=&quot;#加载SD卡的SO库&quot; class=&quot;headerlink&quot; title=&quot;加载SD卡的SO库&quot;&gt;&lt;/a&gt;加载SD卡的SO库&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何编译和使用SO库；&lt;/li&gt;
&lt;li&gt;分析Android中加载SO库相关的源码；&lt;/li&gt;
&lt;li&gt;如何加载SD卡中的SO库（也是动态加载APK需要解决的问题）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004062899&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载补充 加载SD卡的SO库&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;简单的动态加载模式&quot;&gt;&lt;a href=&quot;#简单的动态加载模式&quot; class=&quot;headerlink&quot; title=&quot;简单的动态加载模式&quot;&gt;&lt;/a&gt;简单的动态加载模式&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何创建我们需要的dex文件；&lt;/li&gt;
&lt;li&gt;如何加载dex文件里面的类；&lt;/li&gt;
&lt;li&gt;动态加载dex文件在ART虚拟机的兼容性问题；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004062952&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载入门 简单加载模式&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;代理Activity的模式&quot;&gt;&lt;a href=&quot;#代理Activity的模式&quot; class=&quot;headerlink&quot; title=&quot;代理Activity的模式&quot;&gt;&lt;/a&gt;代理Activity的模式&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何启动插件APK中没有注册的Activity&lt;/li&gt;
&lt;li&gt;代理Activity模式开源项目“dynamic-load-apk”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004062972&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载进阶 代理Activity模式&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;动态创建Activity的模式&quot;&gt;&lt;a href=&quot;#动态创建Activity的模式&quot; class=&quot;headerlink&quot; title=&quot;动态创建Activity的模式&quot;&gt;&lt;/a&gt;动态创建Activity的模式&lt;/h4&gt;&lt;p&gt;内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何在运行时动态创建一个Activity；&lt;/li&gt;
&lt;li&gt;自定义ClassLoader并偷梁换柱替换想要加载的类；&lt;/li&gt;
&lt;li&gt;动态创建Activity模式开源项目“android-pluginmgr”&lt;/li&gt;
&lt;li&gt;代理模式与动态创建类模式的区别；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址：&lt;a href=&quot;http://segmentfault.com/a/1190000004077469&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android动态加载黑科技 动态创建Activity模式&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;还未发布的内容&quot;&gt;&lt;a href=&quot;#还未发布的内容&quot; class=&quot;headerlink&quot; title=&quot;还未发布的内容&quot;&gt;&lt;/a&gt;还未发布的内容&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用“环境注入”的模式；&lt;/li&gt;
&lt;li&gt;使用动态加载技术的情形；&lt;/li&gt;
&lt;li&gt;使用动态加载方式项目的项目结构调整和开发调试方式；&lt;/li&gt;
&lt;li&gt;开源项目“Android-Frontia”，动态加载框架的项目，专注于“插件化”和“宿主与插件之间的通讯”；&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xih5c.com1.z0.glb.clouddn.com/15-11-30/1635252.jpg&quot; alt=&quot;android-dynamical-loading&quot; title=&quot;android-dynamical-loading&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Android开发中采用动态加载技术，可以达到不安装新的APK就升级APP功能的目的，可以用来到达快速发版的目的，也可以用来修复一些紧急BUG。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/categories/Android/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
</feed>
